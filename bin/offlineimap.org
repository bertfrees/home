* OfflineIMAP

#+NAME: offlineimap
#+BEGIN_SRC clojure :tangle offlineimap :tangle-mode (identity #o755)
#!/usr/bin/env bb

;; This file is automatically generated from offlineimap.org. Don't make
;; changes to this file directly.

(require '[babashka.process :refer [exec sh]]
         '[clojure.java.io :as io])

(let [brew-home (io/file (case (.trim (:out (sh "uname -m")))
                           "x86_64" "/usr/local"
                           "/opt/homebrew"))
      offlineimap (io/file brew-home "bin/offlineimap")
      home-dir (.getParentFile (.getParentFile (io/file *file*)))]
  (when (not (= 0 (:exit (sh {:dir home-dir :out :inherit :err :inherit}
                             "bin/make" (.getPath offlineimap)
                                        ".offlineimaprc"
                                        ".netrc"
                                        "gpg"
                                        "Library/LaunchAgents/offlineimap.plist"
                                        ))))
    (System/exit 1))
  (when (Boolean/parseBoolean (System/getenv "OFFLINEIMAP_RUN_FROM_LAUNCHD"))
    (apply exec {:extra-env {"PYTHONPATH" "/opt/homebrew/Cellar/offlineimap/8.0.0_1/libexec/lib/python3.12/site-packages"}}
                "/opt/homebrew/opt/python@3.10/libexec/bin/python3"
                offlineimap
                ,*command-line-args*))
  (let [log-file (io/file home-dir ".offlineimap/err.log")]
    (when (not (= 0 (:exit (sh {:out :inherit :err :inherit}
                               "launchctl" "start" "offlineimap"))))
      (System/exit 1))
    (exec "bash" "-c"
          (format "maybe_stop() {
                     screen bash -c \" \\
                       dialog --yesno 'Keep offlineimap running in the background?' 0 0 \\
                       || launchctl stop offlineimap\"
                   }
                   trap 'pkill -P $$; maybe_stop; exit' INT TERM
                   tail -f %s & wait"
                   (.getAbsolutePath log-file)))))
#+END_SRC

** Configuration

- enable [[https://myaccount.google.com/signinoptions/two-step-verification][2-factor authentication]]
- create an application password in [[https://myaccount.google.com/apppasswords][Google app passwords]]
- store the password in [[file:~/.authinfo.gpg][~/.authinfo.gpg]]
- create a SSL certificate file
  - open Keychain Access
  - look for "GlobalSign Root CA" in system roots certificates
  - export in PEM format
  - rename file to ~/.offlineimap/Account-gmail/globalsign-root-ca.pem

#+NAME: .offlineimaprc
#+BEGIN_SRC clojure :tangle ../.offlineimaprc :tangle-mode (identity #o755)
# This file is automatically generated from bin/offlineimap.org. Don't make
# changes to this file directly.

[general]
accounts = gmail
maxsyncaccounts = 1

[Account gmail]
localrepository = gmail-local
remoterepository = gmail-remote
synclabels = yes
labelheader = X-Keywords
postsynchook = ~/.offlineimap/postsync
autorefresh = 5

[Repository gmail-local]
type = GmailMaildir
localfolders = ~/Mail

[Repository gmail-remote]
type = Gmail
maxconnections = 1
remoteuser = bertfrees@gmail.com
realdelete = no
folderfilter = lambda name: name in ["[Gmail]/Prullenbak",
                                     "[Gmail]/Concepten",
                                     "[Gmail]/Alle e-mail"]
nametrans = lambda name: {"[Gmail]/Alle e-mail": "all",
                          "[Gmail]/Concepten": "drafts",
                          "[Gmail]/Prullenbak": "trash"}.get(name, name)
sslcacertfile = ~/.offlineimap/Account-gmail/globalsign-root-ca.pem
#+END_SRC

#+NAME: postsync
#+BEGIN_SRC clojure :tangle ../.offlineimap/postsync :tangle-mode (identity #o755)
#!/usr/bin/env bb

;; This file is automatically generated from ../bin/offlineimap.org. Don't make
;; changes to this file directly.

(require '[babashka.process :refer [sh exec]]
         '[clojure.java.io :as io]
         '[clojure.string :as str])

(let [home-dir (.getParentFile (.getParentFile (io/file *file*)))]
  (when (not (= 0 (:exit (sh {:dir home-dir :out :inherit :err :inherit}
                         "bin/make" "mu"))))
    (System/exit 1))
  (let [emacs-running #(.exists (io/file (str (System/getProperty "java.io.tmpdir")
                                              "/emacs"
                                              (.trim  (:out (sh  {:out :string} "id -u bert")))
                                              "/server")))
        postindex (io/file (.getParentFile (io/file *file*)) "postindex")
        postindex (.getAbsolutePath postindex)]
    (if (emacs-running)
      (let [emacsclient (io/file home-dir "bin/emacsclient")
            emacsclient (fn [& args] (:exit (apply sh {:err :inherit} emacsclient args)))]
        (emacsclient "-e" (format "(progn
                                     (mu4e t)
                                     (let ((reset-mu4e-index-updated-hook mu4e-index-updated-hook))
                                       (setq mu4e-index-updated-hook
                                             (cons (lambda ()
                                                     (progn (message (shell-command-to-string \"%s\"))
                                                            (setq mu4e-index-updated-hook
                                                                  reset-mu4e-index-updated-hook)))
                                                   mu4e-index-updated-hook))
                                       (mu4e-update-index)))"
                                  postindex)))
      (do (when (not (= 0 (:exit (sh {:out :inherit :err :inherit} "mu" "index"))))
            (System/exit 1))
          (exec postindex)))))
#+END_SRC

#+NAME: postindex
#+BEGIN_SRC clojure :tangle ../.offlineimap/postindex :tangle-mode (identity #o755)
#!/usr/bin/env bb

;; This file is automatically generated from ../bin/offlineimap.org. Don't make
;; changes to this file directly.

(require '[babashka.process :refer [sh]]
         '[clojure.java.io :as io]
         '[clojure.string :as str])
(import '[java.text SimpleDateFormat])

(let [last-sync (io/file (.getParentFile (io/file *file*)) "last-sync")]
  (when (.exists last-sync)
    (let [last-modified (.format (SimpleDateFormat. "yyyy-MM-dd'T'HH:mm:ssX")
                                 (.lastModified last-sync))
          mailinglists-to-ignore ["accessibility@global.libreoffice.org"
                                  "transition-to-accessible-epub@mail.daisy.org"
                                  "xproc-dev@w3.org"]
          mu-find ["mu" "find" "-f" "f\ts" "-s" "date" "flag:unread"
                                                       "AND" "maildir:/all"
                   "AND" (str "date:" last-modified "..")
                   (map (fn [x] ["AND" "NOT" (str "tag:Mailinglijsten/" x)]) mailinglists-to-ignore)]
          mu-find (flatten mu-find)
          mu-find (apply sh {:out :string :err :inherit} mu-find)]
      (case (:exit mu-find)
        0 (let [new-mail (str/split-lines (:out mu-find))]
            (when (not (empty? new-mail))
              (binding [*out* *err*]
                (println "New messages:")
                (println (str/join "\n" new-mail)))
              (sh {:out :inherit :err :inherit}
                  "terminal-notifier"
                  "-title" "New mail"
                  "-message" (let [mail-count (count new-mail)
                                   sender (map (fn [m]
                                                 (-> m (str/split #"\t")
                                                       first
                                                       (.replaceAll " <.*>$" "")))
                                               new-mail)
                                   sender (distinct sender)
                                   sender-count (count sender)
                                   first-sender (take 3 sender)
                                   other-sender (when-let [other-sender (seq (drop 3 sender))]
                                                  [(apply str [(count other-sender)
                                                               " other"
                                                               (when (> (count other-sender) 1) "s")])])
                                   sender (concat first-sender other-sender)
                                   message ["New message"
                                            (when (> mail-count 1) "s")
                                            " from "
                                            (when (> (count sender) 1)
                                              [(str/join ", " (butlast sender))
                                               " and "])
                                            (last sender)]
                                   message (str/join "" (remove nil? (flatten message)))]
                                 message)
                  "-sound" "default"
                  "-sender" "com.apple.mail")
              ;; update last-sync only when new messages are found, so we can be absolutely sure
              ;; we don't miss any notifications in case of possible synchronization issues
              (sh "touch" (.getAbsolutePath last-sync))))
        2 (binding [*out* *err*]
            (println "No new messages"))
        :else (System/exit 1)))))
#+END_SRC
