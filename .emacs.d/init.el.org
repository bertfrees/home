* Emacs configuration
** Miscellaneous

#+NAME: config
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil
      inhibit-startup-screen t
      ring-bell-function 'ignore
      make-backup-files nil
      auto-save-default nil
      vs-follow-symlinks t
      line-move-visual nil
      mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-follow-mouse 't)
(xterm-mouse-mode 1)
(fset 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "C-x i") 'insert-char)
(global-auto-revert-mode t)
(electric-pair-mode t)

(use-package dired
  :bind (:map dired-mode-map
         (("RET" . dired-find-alternate-file)
          ("^"   . (lambda ()
                     (interactive)
                     (find-alternate-file "..")))))
  :config
  (put 'dired-find-alternate-file 'disabled nil))

(use-package popwin
  :ensure t
  :config (popwin-mode 1))

(use-package undo-tree
  :hook (prog-mode text-mode)
  :init
  (require 'popwin)
  (push '(" *undo-tree*" :width 0.2 :position right) popwin:special-display-config)
  :bind (:map undo-tree-map
         ("C-z" . undo-tree-undo))
  :config (setq undo-tree-auto-save-history nil))

(global-unset-key (kbd "C-z"))

#+END_SRC

** Package manager

#+NAME: config
#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
(when (not package-archive-contents) ;; to avoid long startup time
                                     ;; to manually update the list, run M-x list-packages and update with U
  (package-refresh-contents))

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-defer t
      use-package-always-ensure nil
      use-package-verbose t)

#+END_SRC

** Theme

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; choose a theme to prevent Emacs from inheriting the background
;; and foreground of the terminal when in tty mode
(load-theme 'leuven)

(require-theme 'modus-themes)

#+END_SRC

** Modifier keys

#+NAME: config
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (progn
    (setq mac-function-modifier      'none
          mac-control-modifier       'control
          mac-command-modifier       'control
          mac-option-modifier        'meta
          mac-right-command-modifier 'super
          mac-right-control-modifier 'none
          mac-right-option-modifier  'none)))

#+END_SRC

** Server

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package server
  :demand t
  :config
  (or (server-running-p) (server-start))
  ;; ask to save buffers and kill frame or Emacs
  (defun save-buffers-kill-terminal-or-server-with-confirmation (&optional arg)
    (interactive)
    (if (not (frame-parameter nil 'client))
        ;; if the current frame has no client, kill Emacs
        ;; should normally not happen because we start the server in
        ;; the background (with --daemon)
        (save-buffers-kill-emacs arg)
      (if (and (eq (frame-parameter nil 'client) 'nowait)
               ;; if it's a "nowait" frame ask whether to kill the frame
               ;; and keep Emacs running, or kill Emacs
               (yes-or-no-p "Kill server (y) or kill only this frame (n)?"))
          (save-buffers-kill-emacs)
        ;; if emacsclient was started with a list of files to edit,
        ;; then only ask to save these files
        (server-save-buffers-kill-terminal arg))))
  (global-set-key (kbd "C-x C-c") 'save-buffers-kill-terminal-or-server-with-confirmation))

#+END_SRC

** Git

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package password-store
  :ensure t
  :autoload password-store-get)

(use-package magit
  :ensure t
  :commands magit-status
  :custom
  (magit-highlight-whitespace)
  (magit-diff-refine-hunk t)
  (magit-diff-use-overlays t)
  (magit-status-expand-stashes nil)
  (magit-repository-directories '(("/Users/bert/src" . 1)
                                  ("/Users/bert/src/github" . 2)))
  :config
  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (add-hook 'magit-section-set-visibility-hook
            (lambda (section)
              (and (not magit-insert-section--oldroot)
                   (let ((type (with-slots (type) section type)))
                     (or (eq type 'untracked)
                         (eq type 'remote)
                         (eq type 'tag)))
                   'hide)))
  (defun magit-use-ivy-to-read-repository (orig-fun &rest args)
    (unwind-protect
        (progn
          (ivy-mode +1)
          (apply orig-fun args))
      (ivy-mode -1)))
  (advice-add 'magit-read-repository :around #'magit-use-ivy-to-read-repository)
  ;; get rsa passphrase from pass
  (defadvice magit-process-password-prompt (around magit-process-rsa-password-prompt (proc string) activate)
    (if (or (string= string "Enter passphrase for key '/home/frees/.ssh/gmail_rsa': ")
            (string= string "Enter passphrase for key '/Users/bert/.ssh/gmail_rsa': "))
        (progn
          (process-send-string proc (concat (password-store-get "ssh-rsa/bertfrees@gmail.com") "\n")))
      ad-do-it)))

#+END_SRC

** Org-mode

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :commands (org-mode org-agenda org-capture org-store-link)
  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link))
  :config
  (set-face-attribute 'org-document-title nil ':height 1.00)
  (set-face-attribute 'org-drawer nil ':foreground "grey")
  (set-face-attribute 'org-meta-line nil ':foreground "grey")
  (setq org-directory "~/Dropbox/org"
        org-default-notes-file (expand-file-name "todo.org" org-directory)
        org-agenda-files
          `(,org-default-notes-file
            ,(expand-file-name "~/Dropbox/org/roam/agenda.org")
            ,(expand-file-name "~/Dropbox/org/roam/liblouis_work.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_daisy_consortium.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_sbs.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_dedicon.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_braille_autoriteit.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_luisterpuntbibliotheek.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_transkript.org")
            ,(expand-file-name "~/Dropbox/org/roam/betaalagenda.org")
            ,(expand-file-name "~/Dropbox/org/roam/vuilophaling.org")
            ,(expand-file-name "~/Dropbox/org/roam/kamerplanten.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/boekhouding.org")
            ,(expand-file-name "~/Dropbox/org/roam/veilingen.org")
            ,(expand-file-name "~/Dropbox/org/pipeline/todo.org")
            ,(expand-file-name "~/Dropbox/org/sbs/todo.org")
            )
        org-startup-folded 'content
        org-cycle-include-plain-lists 'integrate
        org-drawers '("PROPERTIES" "LOGBOOK")
        ;; don't use hard indentation
        org-adapt-indentation nil
        org-src-preserve-indentation t
        org-edit-src-content-indentation 0
        ;; soft indentation can be controlled with https://orgmode.org/manual/Org-Indent-Mode.html
        org-startup-indented t
        org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "DOING(d)" "|" "DONE(v)")
            (sequence "WAITING(w)" "HOLD(h)" "|" "CANCELLED(c)" "MISSED(m)"))
        org-fontify-done-headline nil
        org-todo-keyword-faces
          '(("TODO" :foreground "red" :weight bold)
            ("NEXT" :foreground "orange" :weight bold)
            ("DOING" :foreground "dodger blue" :weight bold)
            ("DONE" :foreground "lime green" :strike-through t :weight bold)
            ("WAITING" :foreground "red" :weight bold)
            ("HOLD" :foreground "red" :weight bold)
            ("CANCELLED" :foreground "purple" :strike-through t :weight bold)
            ("MISSED" :foreground "purple" :strike-through t :weight bold))
        org-hidden-keywords '(title)
        org-clock-history-length 25
        org-clock-in-switch-to-state 'org-clock-in-switch-to-doing
        org-clock-into-drawer t
        org-clock-out-remove-zero-time-clocks t
        org-clock-out-when-done t
        org-clock-auto-clock-resolution 'when-no-clock-is-running
        org-clock-persist t
        org-clock-report-include-clocking-task t
        org-time-stamp-rounding-minutes '(1 1)
        org-duration-format 'h:mm
        org-agenda-dim-blocked-tasks nil
        org-agenda-compact-blocks t
        org-agenda-span 'week
        org-agenda-log-mode-items '(closed state)
        org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2)
        org-agenda-clock-consistency-checks
          '(:max-duration "10:00"
            :min-duration 0
            :max-gap "0:15"
            :gap-ok-around ("12:30" "13:00" "17:30" "18:00" "4:00")
            :default-face ((:background "orange") (:foreground "black"))
            :overlap-face ((:background "red") (:foreground "white"))
            :gap-face nil
            :no-end-time-face nil
            :long-face nil
            :short-face nil)
        org-agenda-window-setup 'current-window
        org-agenda-tags-column -120
        org-agenda-custom-commands
          '((" " "Agenda"
             ((agenda "" ((org-agenda-span 'day)
                          (org-agenda-prefix-format " %i %?-12t% s")
                          (org-agenda-remove-tags t)))
              nil))))
  (defun org-clock-in-switch-to-doing (kw)
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (when (member (org-get-todo-state) '("TODO" "NEXT"))
        "DOING")))
  (add-hook 'org-mode-hook (lambda () (setq fill-column 100)))
  (defun org-timestamp-at-point-as-utc-time ()
    (interactive)
    (when (org-at-timestamp-p 'lax)
      (message "%s"
               (format-time-string "%H:%M UTC"
                                   (org-time-string-to-time
                                    (apply 'buffer-substring
                                           (flatten-tree (org-in-regexp org-ts-regexp3))))
                                   t))))
  (use-package org-indent
    :config
    (set-face-attribute 'org-indent nil ':background "#e0f4ff")))

(use-package emacsql-sqlite-builtin
  :ensure t)

(use-package org-roam
  :ensure t
  :defer 300
  :after emacsql-sqlite-builtin ;; see https://org-roam.discourse.group/t/org-roam-fails-with-selecting-deleted-buffer-error/3353/9
  :commands (org-roam-capture
             org-roam-buffer-toggle)
  :autoload (org-roam-node-find
             org-roam-node-insert)
  :bind (("C-c n f" . org-roam-node-find-with-ivy)
         ("C-c n i" . org-roam-node-insert-with-ivy)
         ("C-c n c" . org-roam-capture)
         ("C-c n l" . org-roam-buffer-toggle))
  :config
  (setq org-roam-v2-ack t
        org-roam-directory "~/Dropbox/org/roam"
        org-roam-node-display-template "${title:*} ${tags:0} ${refs:0}"
        org-roam-capture-templates
        '(("d" "default" plain
           "%?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+FILETAGS:\n#+TITLE: ${title}\n")
           :unnarrowed t)))
  (org-roam-db-autosync-enable))

(defun org-roam-node-find-with-ivy ()
  (interactive)
  (unwind-protect
      (progn
        (ivy-mode +1)
        (org-roam-node-find))
    (ivy-mode -1)))
(defun org-roam-node-insert-with-ivy ()
  (interactive)
  (unwind-protect
      (progn
        (ivy-mode +1)
        (org-roam-node-insert))
    (ivy-mode -1)))

(global-set-key (kbd "C-c n f") 'org-roam-node-find-with-ivy)
(global-set-key (kbd "C-c n i") 'org-roam-node-insert-with-ivy)
(global-set-key (kbd "C-c n c") 'org-roam-capture)
(global-set-key (kbd "C-c n l") 'org-roam-buffer-toggle)

#+END_SRC

** Selection, completion, navigation
*** Auto-complete

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package auto-complete
  :ensure t
  :commands auto-complete-mode
  :config
  (setq-default ac-sources '())
  (setq ac-auto-start nil
        ac-dwim t
        ac-ignore-case t
        ac-menu-height 10
        ac-quick-help-prefer-pos-tip t
        ac-use-quick-help t
        ac-quick-help-height 20
        ac-quick-help-delay 1
        ac-use-comphist nil)
  (ac-set-trigger-key "TAB"))

#+END_SRC

*** Ido

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package ido
  :config
  (setq ido-enable-prefix nil
        ido-enable-flex-matching t
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-max-prospects 10
        ido-default-file-method 'selected-window
        ido-everywhere t)
  :bind
  (("M-x" . (lambda ()
              (interactive)
              (call-interactively
               (intern
                (ido-completing-read
                 "M-x "
                 (all-completions "" obarray 'commandp)
                 'commandp t nil 'extended-command-history
                 (car extended-command-history))))))
   ;; in addition to the default C-x b, because I often type C-x C-b by accident
   ("C-x C-b" . 'ido-switch-buffer)))

(ido-mode t)

#+END_SRC

*** Ivy

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :autoload ivy-mode)

#+END_SRC

*** Find File at Point

Find File at Point (ffap) is a built-in Emacs library that other tools such as Ido makes use of.

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package ffap
  :config
  ;; adapted from https://www.emacswiki.org/emacs/FindFileAtPoint:
  (defvar ffap-file-at-point-line-number nil
    "Variable to hold line number from the last `ffap-file-at-point' call.")
  ;; add `[', `]' and `,' to list of characters to include in (ffap-string-at-point)
  (add-to-list 'ffap-string-at-point-mode-alist '(file "--:\\\\${}+<>@-Z_[:alpha:]~*?[]," "{<@" "@>;.,!:}"))
  (defadvice ffap-file-at-point (after ffap-store-line-number activate)
    "Search `ffap-string-at-point' for a line number pattern and
save it in `ffap-file-at-point-line-number' variable."
    (let* ((string (ffap-string-at-point))
           (name
            (or (condition-case nil
                    (and (not (string-match "//" string)) ; foo.com://bar
                         (substitute-in-file-name string))
                  (error nil))
                string))
           (line-number-string
            (and (string-match ":\\(\\([0-9]+\\)\\|\\[\\([0-9]+\\),[0-9]+\\]\\)" name) ; `:line' or `:line:' or `:[line,column]'
                                                                                       ; (but note that the first : after files in rgrep
                                                                                       ; window is actually a ^@)
                 (concat
                  (match-string 2 name)
                  (match-string 3 name))))
           (line-number
            (and line-number-string
                 (string-to-number line-number-string))))
      (if (and line-number (> line-number 0))
          (setq ffap-file-at-point-line-number line-number)
        (setq ffap-file-at-point-line-number nil))))
  (defadvice find-file-at-point (after ffap-goto-line-number activate)
    "If `ffap-file-at-point-line-number' is non-nil goto this line."
    (when ffap-file-at-point-line-number
      (goto-line ffap-file-at-point-line-number)
      (setq ffap-file-at-point-line-number nil)))
  (defadvice ido-find-file (after ido-goto-line-number activate)
    "If `ffap-file-at-point-line-number' is non-nil goto this line."
    (when ffap-file-at-point-line-number
      (goto-line ffap-file-at-point-line-number)
      (setq ffap-file-at-point-line-number nil))))

#+END_SRC

** Cut & paste

#+NAME: config
#+BEGIN_SRC emacs-lisp
(defun interprogram-killring-peek ()
  (shell-command-to-string "/usr/bin/pbpaste"))

(defun interprogram-killring-push (text &optional push)
  (let ((process-connection-type nil))
    (let ((proc (start-process "killring push" "*Messages*" "/usr/bin/pbcopy")))
  (process-send-string proc text)
  (process-send-eof proc))))

(setq save-interprogram-paste-before-kill t
  interprogram-cut-function 'interprogram-killring-push
  interprogram-paste-function 'interprogram-killring-peek)

#+END_SRC

** IRC and Slack

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package erc-terminal-notifier
  :ensure t
  )

(use-package erc
  :commands (libera-chat bitlbee erc-all)
  :config
  (require 'erc-services)
  (require 'erc-terminal-notifier)
  (setq erc-server "localhost"
        erc-server-history-list '("localhost"
                                  "irc.libera.chat")
        erc-nick '("bert" "bfrees")
        erc-nickserv-identify-mode 'both
        erc-autojoin-channels-alist
          '(("Libera.Chat" "#liblouis")
            ;"BitlBee" ... ;; autojoins for BitlBee are handled by BitlBee itself
            ))
  (defun libera-chat ()
    (interactive)
    (erc-tls :server "irc.libera.chat" :port 6697 :nick "bfrees"))
  (defun bitlbee ()
    (interactive)
    (when (not (get-buffer-process "*bitlbee*"))
      (start-process "bitlbee" "*bitlbee*"
                     (expand-file-name "../bin/bitlbee" user-emacs-directory) "-Fn"))
    (erc :server "localhost" :port 6667 :nick "bert"))
  (defun erc-all ()
    (interactive)
    (libera-chat)
    (bitlbee)))

#+END_SRC

** Programming
*** XML

#+NAME: config
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.xml$"   . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.xhtml$" . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.xsd$"   . nxml-mode))

(use-package nxml-mode
  :autoload nxml-mode
  :config
  (setq-default nxml-child-indent 4)
  (setq nxml-slash-auto-complete-flag t)
  (push (expand-file-name "schema/schemas.xml" user-emacs-directory) rng-schema-locating-files)
  (add-to-list 'hs-special-modes-alist
    '(nxml-mode "<!--\\|<[^/>]>\\|<[^/][^>]*[^/]>"
                ""
                "<!--"
                nxml-forward-sexp
                nil))
  (add-hook 'nxml-mode-hook
    (lambda () (local-set-key (kbd "TAB") 'nxml-indent-or-toggle-hiding-or-expand-or-complete)
               (local-set-key (kbd "RET") 'nxml-newline-and-indent-maybe-auto-newline)
               (local-set-key ">" 'nxml-electric-gt)
               (local-set-key (kbd "C-<up>") 'nxml-backward-element)
               (local-set-key (kbd "C-<down>") 'nxml-forward-element)
               (setq-local ac-sources '(ac-source-nxml-tag
                                        ac-source-nxml-attr
                                        ac-source-nxml-attr-value))
               (auto-complete-mode t)
               (auto-complete-nxml-init-project)
               (hs-minor-mode)))
  (defun nxml-forward-sexp (arg)
    (let ((nxml-sexp-element-flag))
      (setq nxml-sexp-element-flag (not (looking-at "<!--")))
      (unless (looking-at "[*]+")
        (condition-case nil
            (nxml-forward-balanced-item arg)
          (error nil)))))
  (defun try-indent ()
    (if (use-region-p)
        (progn
          (indent-region (region-beginning) (region-end))
          t)
      (let* ((point-before-indent (point)))
        (indent-according-to-mode)
        (not (and (equal point-before-indent (point))
                  (not mark-active))))))
  (defun fallback-command (&optional except-command)
    (let* ((saved-local-map (current-local-map)))
      (use-local-map nil)
      (setq unread-command-events
            (append (this-single-command-raw-keys)
                    unread-command-events))
      (let* ((key (read-key-sequence-vector ""))
             (command (and key (key-binding key))))
        (when (and (commandp command)
                   (not (eq command 'except-command)))
          (setq this-command command)
          (call-interactively command))
        (use-local-map saved-local-map))))
  (defun nxml-try-toggle-hiding ()
    (if (hs-already-hidden-p)
      (progn
        (hs-show-block)
        (hs-find-block-beginning)
        t)
      (progn
        (nxml-token-after)
        (when (or (and (eq xmltok-type 'start-tag)
                       (< (- (point) xmltok-start 1) (length (xmltok-start-tag-qname))))
                  (and (eq xmltok-type 'comment)
                       (< (- (point) xmltok-start) 4)))
          (goto-char xmltok-start)
          (hs-hide-block)
          (hs-find-block-beginning)
          t))))
  (defun nxml-indent-or-toggle-hiding-or-expand-or-complete ()
    (interactive)
    (unless (try-indent)
      (unless (nxml-try-toggle-hiding)
        (fallback-command 'nxml-indent-or-toggle-hiding-or-expand-or-complete))))
  (defun nxml-newline-and-indent-maybe-auto-newline ()
    (interactive)
    (nxml-ensure-scan-up-to-date)
    (if (and (not (nxml-get-inside (point)))
             (eq (point) (nxml-scan-element-backward (point) t))
             (looking-at (concat "</" (xmltok-start-tag-qname) ">")))
        (progn
          (newline)
          (save-excursion (newline))
          (nxml-indent-line)
          (save-excursion (forward-char)
                          (nxml-indent-line)))
      (newline)
      (nxml-indent-line)))
  (defun nxml-electric-gt ()
    (interactive)
    (nxml-ensure-scan-up-to-date)
    (insert ">")
    (if (and (eq (nxml-token-before) (point))
             (eq xmltok-type 'start-tag))
        (save-excursion
          (insert (concat "</" (xmltok-start-tag-qname) ">")))))
  (defun nxml-electric-slash (arg)
    (interactive "*P")
    (nxml-ensure-scan-up-to-date)
    (let* ((slash-pos (point))
           (end-tag-p (and (eq (char-before slash-pos) ?<)
                           (not (nxml-get-inside slash-pos))))
           (at-indentation (save-excursion
                             (back-to-indentation)
                             (eq (point) (1- slash-pos)))))
      (self-insert-command (prefix-numeric-value arg))
      (unless arg
        (if nxml-slash-auto-complete-flag
            (if end-tag-p
                (condition-case err
                    (let ((start-tag-end
                           (nxml-scan-element-backward (1- slash-pos) t)))
                      (when start-tag-end
                        (insert (xmltok-start-tag-qname) ">")))
                  (nxml-scan-error nil))
              (if (and (eq (nxml-token-before) (point))
                       (eq xmltok-type 'partial-empty-element))
                  (insert ">")
                (when (and (eq (nxml-token-before) (1+ (point)))
                           (eq xmltok-type 'empty-element))
                  (forward-char)
                  (when (looking-at (concat "[\s\t\n]*</" (xmltok-start-tag-qname) ">"))
                    (while (looking-at "[\s\t\n]")
                      (delete-char 1))
                    (delete-char (+ 3 (length (xmltok-start-tag-qname)))))))))
        (when (and end-tag-p at-indentation)
          (nxml-indent-line)))))
  (defun nxml-pretty-print-region (begin end)
    (interactive "r")
    (when (string-equal major-mode "nxml-mode")
      (save-excursion
        (goto-char begin)
        (while (search-forward-regexp "\>[ \\t]*\<" nil t)
          (backward-char) (insert "\n"))
        (indent-region begin end))))) 

(use-package auto-complete-nxml
  :ensure t
  :autoload auto-complete-nxml-init-project
  :config
  (remove-hook 'nxml-mode-hook 'auto-complete-nxml-setup))

** Shell

See also [[file:../.zshrc.org][.zshrc]]

#+NAME: config
#+BEGIN_SRC emacs-lisp
(defun vterm-buffer-for-directory (&optional directory)
  (let* ((directory (or directory default-directory))
         (directory (expand-file-name directory))
         (buf (if current-prefix-arg
                  nil ;; create new buffer if current-prefix-arg is set
                (progn
                  (require 'cl-lib)
                  (cl-loop for b in (match-buffers '(major-mode . vterm-mode))
                           when (string= directory (expand-file-name
                                                    (buffer-local-value 'default-directory b)))
                           return b))))
         (buf (or buf
                  (let ((default-directory directory))
                    (vterm)))))
    (with-current-buffer buf
      (vterm-dark-theme)) ;; Note that vterm-dark-theme is already applied in vterm-mode-hook,
                          ;; but vterm-mode-hook does not seem te be executed when vterm is
                          ;; started through initial-buffer-choice. Also, for some reason,
                          ;; vterm-dark-theme is not applied correctly to the very first vterm
                          ;; buffer (when the daemon is started), so call it again when
                          ;; emacsclient connects (and every time vterm-buffer-for-directory is
                          ;; called).
    buf))

(defun switch-to-vterm-buffer-for-directory (&optional directory)
  (interactive)
  (switch-to-buffer (vterm-buffer-for-directory directory)))

(setq initial-buffer-choice #'vterm-buffer-for-directory)

;;     C-x !: switch to vterm buffer for current directory
;; C-u C-x !: create new vterm buffer for current directory
(global-set-key (kbd "C-x !") 'switch-to-vterm-buffer-for-directory)

(use-package vterm
  :ensure t
  :autoload vterm--internal
  :bind (:map vterm-mode-map
         ("C-c C-p" . vterm-copy-mode)
         :map vterm-copy-mode-map
         ("C-c C-p" . vterm-copy-mode-done))
  :config
  (setq vterm-buffer-name-string "vterm %s")
  (defun vterm-dark-theme ()
    "Dark theme for vterm buffers."
    (ignore-errors
      (unless (color-dark-p (mapcar (lambda (c) (/ c 65535.0))
                                    (color-values (background-color-at-point))))
        (require 'theme-anchor)
        (theme-anchor-buffer-local 'modus-vivendi))))
  (add-hook 'vterm-mode-hook #'vterm-dark-theme)
  (defvar vterm-execute-buffer nil)
  (defun vterm-execute-region-or-current-line ()
    "Insert text of current line in vterm and execute."
    (interactive)
    (require 'vterm)
    (eval-when-compile (require 'subr-x))
    (let ((command (if (region-active-p)
                       (string-trim (buffer-substring
                                     (save-excursion (region-beginning))
                                     (save-excursion (region-end))))
                     (string-trim (buffer-substring (save-excursion
                                                      (beginning-of-line)
                                                      (point))
                                                    (save-excursion
                                                      (end-of-line)
                                                      (point)))))))
      (let* ((buf (current-buffer))
             (vterm-buffer
              (or (and (buffer-live-p vterm-execute-buffer) vterm-execute-buffer)
                  (if-let ((vterm-buffers (match-buffers '(major-mode . vterm-mode))))
                      (if (= 1 (length vterm-buffers))
                          (car vterm-buffers)
                        (set (make-local-variable 'vterm-execute-buffer)
                             (get-buffer
                              (completing-read "Send command to shell: "
                                               (mapcar #'buffer-name vterm-buffers)
                                               nil t))))
                    (let ((default-directory (read-directory-name
                                              "Send command to new shell in directory: "
                                              default-directory nil t)))
                      (vterm))))))
        (display-buffer vterm-buffer t)
        (switch-to-buffer-other-window vterm-buffer)
        (vterm--goto-line -1)
        (message command)
        (vterm-send-string command)
        (vterm-send-return)
        (switch-to-buffer-other-window buf))))
  (use-package sh-script
    :bind (:map sh-mode-map
                (("C-x C-e" . vterm-execute-region-or-current-line)))))

#+END_SRC

** Putting it all together

#+NAME: init.el
#+BEGIN_SRC emacs-lisp :tangle init.el
;; This file is automatically generated from init.el.org. Don't make
;; changes to this file directly.

<<config>>
#+END_SRC
