* Emacs configuration
** Miscellaneous

- [ ] protect scratch buffer from accidental killing if not empty
  - ask confirmation
  - https://www.emacswiki.org/emacs/protbuf-by-name.el

#+NAME: config
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message nil
      initial-major-mode 'fundamental-mode
      inhibit-startup-screen t
      ring-bell-function 'ignore
      make-backup-files nil
      auto-save-default nil
      vs-follow-symlinks t ;; FIXME: this does not work for find-function: always get confirmation prompt
      line-move-visual nil
      mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-follow-mouse 't)
(tool-bar-mode 0)
(xterm-mouse-mode 1)
(fset 'yes-or-no-p 'y-or-n-p)
(global-auto-revert-mode t)
(electric-pair-mode t)

(global-set-key (kbd "C-x i") 'insert-char)
;;(global-set-key (kbd "C-x k") 'kill-this-buffer) ;; FIXME: usually I don't want to choose the buffer (kill-buffer), but sometimes I do

(use-package dired
  :bind (:map dired-mode-map
         (("RET" . dired-find-alternate-file)
          ("^"   . (lambda ()
                     (interactive)
                     (find-alternate-file "..")))))
  :config
  (put 'dired-find-alternate-file 'disabled nil))

(use-package popwin
  :ensure t
  :config (popwin-mode 1))

(use-package undo-tree
  :hook (prog-mode text-mode)
  :init
  (require 'popwin)
  (push '(" *undo-tree*" :width 0.2 :position right) popwin:special-display-config)
  :bind (:map undo-tree-map
         ("C-z" . undo-tree-undo))
  :config (setq undo-tree-auto-save-history nil
                undo-tree-visualizer-timestamps nil
                undo-tree-visualizer-diff t))

(global-unset-key (kbd "C-z"))

(setq-default bidi-paragraph-direction 'left-to-right)

#+END_SRC

** Package manager

- [-] try straight
  - https://github.com/radian-software/straight.el
  - [[https://github.com/radian-software/straight.el][comparable to el-get]] (built from source, reproducible)
    - but only git support
    - hopefully less buggy
    - hopefully with possibility to easily uninstall packages
  - [[https://github.com/radian-software/straight.el][editing packages locally is trivial]]
    - just edit source files
    - can commit to fork of package
    - could even commit to https://github.com/bertfrees/home?
      - is it possible to have a local repo only (without a reference to a git repo in the recipe)?
- [-] issue with using both package.el and straight is that a package may be installed by both
  (because it is a dependency of another package)
  - note that package adds all packages to the load-path during initialize, straight only does it
    when use-package is called
    - this means uninstallation of an elpa package is needed to completely remove it
  - how does straight resolve dependencies?
    - dependencies taken from Package-Requires in header of main package file
    - from dependency names, recipes are looked up in recipe repositories
      - straight-recipe-repositories = '(org-elpa melpa gnu-elpa-mirror nongnu-elpa el-get emacsmirror-mirror)
      - unless you have specified a recipe for the dependency
  - hack: add packages to straight-built-in-pseudo-packages and package--builtin-versions
    - https://www.reddit.com/r/emacs/comments/s6c1ga/straight_how_not_to_load_packagerequires/
    - https://emacs.stackexchange.com/questions/24290/how-to-install-package-without-install-dependencies-through-package
    - issues with this approach
      - uninstalling an elpa package is not possible without removing all its dependent packages
        first
      - because we're tricking the package managers into believing that certain packages are
        built-in, care must be taken to install packages in the right order
      - dependencies of the exclusions of a package manager must be installed explicitly with that
        package manager, and must be defined as exclusions for the other package manager: becomes a
        real pain
        - installing dependencies could be done within the :init of the use-package?
        - adding exclusions to straight-built-in-pseudo-packages also
        - but adding exclusions to package--builtin-versions must be done before package-initialize!
  - easier to switch to 100% straight

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name
        "straight/repos/straight.el/bootstrap.el"
        (or (bound-and-true-p straight-base-dir)
            user-emacs-directory)))
      (bootstrap-version 7))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; make package.el and straight.el play nicer together
;; keep track of which packages need to be installed by which package manager

;; => automatically add certain packages to package--builtin-versions
;;    -> could be done with a macro or function that also does straight-register-package
(require 'package)
(add-to-list 'package--builtin-versions '(forge 0 3 2))

;; => automatically add dependencies of the package straight-built-in-pseudo-packages
;;    -> unless a dependency is already in package--builtin-versions
;;    -> could be done with a macro or function that also does package-install
;;       - (unless (package-installed-p x) (package-install x))
;;       - possibly lazily before straight installs the dependent package
;;    -> list of dependencies could be determined automatically from Require-Packages
(add-to-list 'straight-built-in-pseudo-packages 'let-alist)
(add-to-list 'straight-built-in-pseudo-packages 'compat)
(add-to-list 'straight-built-in-pseudo-packages 'closql)
(add-to-list 'straight-built-in-pseudo-packages 'dash)
(add-to-list 'straight-built-in-pseudo-packages 'emacsql)
(add-to-list 'straight-built-in-pseudo-packages 'ghub)
(add-to-list 'straight-built-in-pseudo-packages 'magit)
(add-to-list 'straight-built-in-pseudo-packages 'markdown-mode)
(add-to-list 'straight-built-in-pseudo-packages 'seq)
(add-to-list 'straight-built-in-pseudo-packages 'transient)
(add-to-list 'straight-built-in-pseudo-packages 'yaml)
(add-to-list 'straight-built-in-pseudo-packages 'org-ql)
(add-to-list 'straight-built-in-pseudo-packages 's)
(add-to-list 'straight-built-in-pseudo-packages 'ts)

;(unless (package-installed-p 'compat) (package-install 'compat))
;...

(setq straight-host-usernames '((github . "bertfrees")))

;; package.el
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
(when (not package-archive-contents) ;; to avoid long startup time
                                     ;; to manually update the list, run M-x list-packages and update with U
  (package-refresh-contents))

;; use-package
(package-install 'use-package)
(require 'use-package)
(setq use-package-always-defer t
      use-package-always-ensure nil
      use-package-verbose t)

#+END_SRC

** Theme

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; choose a theme to prevent Emacs from inheriting the background
;; and foreground of the terminal when in tty mode
(load-theme 'leuven)

(require-theme 'modus-themes)
;(load-theme 'modus-vivendi)
;(load-theme 'modus-operandi)

(use-package auto-dark
  :ensure t
  :config
  (setq auto-dark-dark-theme 'modus-vivendi
        auto-dark-light-theme 'leuven ; nil to disable theme
        auto-dark-polling-interval-seconds 60
        auto-dark-allow-osascript t))
;(auto-dark-mode t)

#+END_SRC

** Modifier keys

#+NAME: config
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (progn
    (setq mac-function-modifier      'none
          mac-control-modifier       'control
          mac-command-modifier       'control
          mac-option-modifier        'meta
          mac-right-command-modifier 'super
          mac-right-control-modifier 'none
          mac-right-option-modifier  'none)))

#+END_SRC

** Server

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package server
  :demand t
  :config
  (or (server-running-p) (server-start))
  ;; ask to save buffers and kill frame or Emacs
  (defun save-buffers-kill-terminal-or-server-with-confirmation (&optional arg)
    (interactive)
    (if (not (frame-parameter nil 'client))
        ;; if the current frame has no client, kill Emacs
        ;; should normally not happen because we start the server in
        ;; the background (with --daemon)
        (save-buffers-kill-emacs arg)
      (if (and (eq (frame-parameter nil 'client) 'nowait)
               ;; if it's a "nowait" frame ask whether to kill the frame
               ;; and keep Emacs running, or kill Emacs
               (yes-or-no-p "Kill server (y) or kill only this frame (n)?"))
          (save-buffers-kill-emacs)
        ;; if emacsclient was started with a list of files to edit,
        ;; then only ask to save these files
        (server-save-buffers-kill-terminal arg))))
  (global-set-key (kbd "C-x C-c") 'save-buffers-kill-terminal-or-server-with-confirmation))

#+END_SRC

** Git

- [-] try magit-forge
  - https://github.com/magit/forge
  - https://magit.vc/manual/forge/
  - [X] setup
    - set Github user name
      - git config --global github.user bertfrees
    - create token
      - https://magit.vc/manual/forge/Token-Creation.html
      - https://magit.vc/manual/ghub/Creating-a-Token.html
      - go to https://github.com/settings/tokens
      - generate new token (classic)
      - note: forge
      - no expiration
      - scopes
        - repo (grants full read/write access to private and public repositories)
        - user (grants access to profile information)
        - read:org (grants read-only access to organization membership)
    - store token
      - https://magit.vc/manual/ghub/Storing-a-Token.html
      - add to ~/.authinfo.gpg
        - machine api.github.com login bertfrees^forge password ...
      - also add to ~/src/github/bertfrees/password-store/github-tokens/forge.pgp (pass edit github-tokens/forge)
    - initial pull ~(forge-pull)~ or ~f n~
  - [X] how to ~forge-add-repository~ and afterwards pull topics in a way that they still contain
    all the correct metadata (labels, milestones, assignees, etc.)?
    - workaround is to reset database for the repository with ~M-x forge-remove-repository~
      - could this be done automatically on first forge-pull?
      - really problematic because after a forge-remove-repository the repository can sometimes not
        be added anymore, and only workaround is deleting the database file (which is in theory not
        a problem, if syncing wasn"t an issue, and if you didn't have to fetch all notifications
        for each individual repository)
    - seems to have been fixed in latest version
  - [ ] issue: metadata (labels etc.) missing from topics from repositories that haven't been pulled
    yet
    - when repo cloned and all topics fetched afterwards, metadata is still missing from the single
      topic that was viewed
    - moreover, a lot of issues missing!
    - workaround is to reset database for the repository with ~M-x forge-remove-repository~
      - could this be done automatically on first forge-pull?
    - [ ] better solution : detect whether repository has been cloned: if not, ask to first clone it
      automatically and fetch topics
      - can we improve a forge function?
      - or do it in consult-gh-forge--issue-view?
  - [ ] completion for mentions in forge-post buffer
- [ ] try gh-notify
  - https://github.com/anticomputer/gh-notify
- [X] try consult-gh
  - requires github cli: ~make -C ~ gh~
  - https://github.com/armindarvish/consult-gh
  - https://www.youtube.com/watch?v=DbRmd75Ywt8
- [ ] try git-link
  - https://github.com/sshaw/git-link
- [ ] git-gutter
- [X] org-mode links to source code
  - [X] https://github.com/magit/orgit
  - [ ] compare with my own implementation
    - orgit doesn't seem to support links to files within a revision
  - [ ] if i move to orgit, i should add some wrapper code to handle magit: links using orgit
- [-] open Github issue links from mu4e, org-mode and forge topic buffers with forge
  - by getting repo and issue number and passing it to consult-gh-forge--issue-view
    - e.g. ~(consult-gh-forge--issue-view "daisy/pipeline-ui" "220")~
  - [X] mu4e: mu4e--view-browse-url-from-binding
  - [X] forge: markdown-follow-link-at-point
  - [X] org-mode: org-open-at-point
    - note that some org-mode files also have custom "gh:" links: turn these into regular links
      again
      - how does my old emacs handle these?
    - [X] also tried https://github.com/magit/orgit-forge
      - problem: orgit-forge stores id from forge database in link, and can not open link if topic has
        not been pulled already
        - ~(forge-topic-setup-buffer (forge-get-topic id))~
        - the id doesn't seem to be something that comes from github
        - if database is cleared, and topics pulled again, the same topic has the same id, but this
          doesn't mean the id can be used to find the topic
        - where does forge store its (meta)data?
          - ~/.emacs.d/forge-database.sqlite
          - there is also .git/refs/pullreqs in the individual projects
  - [X] issue: can not show topic if not pulled yet: first pull notifications
  - [ ] issue: can not show topic if repository not pulled?
    - opening topic from notifications list in forge itself does work
  - [ ] issue: can not see commits of a pr because "not inside a git repository"
    - solution: detect whether project has already been cloned, and first cd to that directory and
      pull
    - also: after replying to a topic, can not automatically pull from repo
  - [ ] support going to specific comment
- [-] flag email as read/done/saved if notification is flagged as read/done/saved in forge?
  - [-] more feasible solution: function to move all github emails corresponsing to "done"
    notifications to trash
    - trigger function when "Github notifications" bookmark is called
    - start using forge to browse notifications
    - don't show github notifications in inbox
    - label with "github-notifications-trash" label instead of directly moving to trash
- [ ] find a way to view/manage github projects in emacs?
  - https://github.com/magit/ghub/issues/107
  - ghi can view projects
  - consult-gh can't
- [ ] find a way to do code reviews in emacs
  - https://github.com/wandersoncferreira/code-review
  - https://github.com/charignon/github-review

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package password-store
  :ensure t
  :autoload password-store-get)

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; FIXME: ⛔ Error (use-package): magit/:config: Cannot open load file: No such file or directory, closql
(use-package magit
  :ensure t
  :commands magit-status
  :custom
  (magit-highlight-whitespace)
  (magit-diff-refine-hunk t) ;; FIXME: does not work?
  (magit-diff-use-overlays t)
  (magit-status-expand-stashes nil)
  (magit-repository-directories '(("/Users/bert/src" . 1)
                                  ("/Users/bert/src/github" . 2)
                                  ("/Users/bert/src/bitbucket" . 2)
                                  ("/Users/bert/.emacs.d/straight/repos" . 1)))
  :config
  (custom-set-faces
   '(diff-refine-added ((t (:background "#66dd55"))))
   '(diff-refine-removed ((t (:background "#ff8877")))))
  (require 'forge)
  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (add-hook 'magit-section-set-visibility-hook
            (lambda (section)
              (and (not magit-insert-section--oldroot)
                   (let ((type (with-slots (type) section type)))
                     (or (eq type 'untracked)
                         (eq type 'remote)
                         (eq type 'tag)))
                   'hide)))
  (defun magit-use-ivy-to-read-repository (orig-fun &rest args)
    (unwind-protect
        (progn
          (ivy-mode +1)
          (apply orig-fun args))
      (ivy-mode -1)))
  (advice-add 'magit-read-repository :around #'magit-use-ivy-to-read-repository)
  ;; get rsa passphrase from pass
  (defadvice magit-process-password-prompt (around magit-process-rsa-password-prompt (proc string) activate)
    (if (or (string= string "Enter passphrase for key '/home/frees/.ssh/gmail_rsa': ")
            (string= string "Enter passphrase for key '/Users/bert/.ssh/gmail_rsa': "))
        (progn
          (process-send-string proc (concat (password-store-get "ssh-rsa/bertfrees@gmail.com") "\n")))
      ad-do-it))
  (magit-wip-mode)
  (add-hook 'magit-section-movement-hook
            'magit-log-maybe-update-blob-buffer)
  (defun magit-stash-rename (&optional stash desc)
    (interactive)
    (let* ((stash (or stash
                      (magit-read-stash "Rename stash (number): ")))
           (desc (read-string "New description: "
                              (or desc
                                  (substring
                                   (cl-find-if
                                    (apply-partially 'string-prefix-p (concat stash ":"))
                                    (magit-git-lines "stash" "list"))
                                   (+ 2 (length stash)))))))
      (magit-run-git "stash-rename" stash desc)))
  )

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; FIXME: synchronization with Github is not good
;; -> https://github.com/magit/forge/issues/367
;; -> see forge-notifications-github-kludge
;; => in latest version (now using d3b14f2) too many notifications are marked done
;;    - see commit 93d3f2a: "When first pulling notifications, mark none as pending"
;;    - better than too many notifications because i still have the email backup
;;    - solution could be to mark all pending as unread
;;      - but also means i should read all done? or is this automatic?
;; => other solution is to simply never look at notifications on Github
;;    - but what if forge database is reset?
;; FIXME: add ability to mark several notifications before executing all the marks
(use-package forge
  ;; FIXME: need to use older version (3908514) of forge to make it compatible with consult-gh-forge
  ;; -> see https://github.com/armindarvish/consult-gh/issues/102
  ;; -> update when consult-gh is updated?
  ;; => for now disabled because of issues with older version of forge
  ;; FIXME: can not checkout specific version with straight
  ;; -> check out desired version after the clone
  ;; -> then do a M-x straight-freeze-versions
  ;;    - this will create the lockfile ~/.emacs.d/straight/versions/default.el
  :straight (forge :type git :host github :repo "magit/forge")
  :bind (("C-c g h n" . forge-list-notifications))
  :autoload (browse-github-issue-url-with-forge)
  :config
  (custom-set-faces
   '(forge-notification-pending ((t nil))))
  (transient-append-suffix 'forge-notifications-menu '(0)
    [:hide always
     ("<up>"     magit-previous-line)
     ("<down>"   magit-next-line)])
  (transient-append-suffix 'forge-topics-menu '(0)
    [:hide always
     ("<up>"     magit-previous-line)
     ("<down>"   magit-next-line)])
  (defun browse-github-issue-url-with-forge (url)
    (when (string-match
           "^https?://github.com/\\([^/]+/[^/]+\\)/\\(pull\\|issues\\)/\\([0-9]+\\)\\(#\\(issuecomment\\|event\\)-.+\\)?$"
           url)
      (let ((repo (match-string 1 url))
            (issue (match-string 3 url)))
        ;; no need to pull notifications if we already just did it
        ;; (see mu4e-sync-github-notifications-before-search)
        (unless (and (boundp 'mu4e--search-last-query)
                     (string= mu4e--search-last-query mu4e-github-notifications-query))
          (require 'forge)
          (forge-pull-notifications)) ;; FIXME: check if this is synchronous
        (require 'consult-gh-forge)
        (consult-gh-forge--issue-view repo issue)
        t)))
  (use-package markdown-mode
    :bind
    (("C-c C-o" . markdown-follow-link-at-point))
    :config
    (defun markdown-browse-github-issue-url-with-forge (orig-fun &rest args)
      (if (not current-prefix-arg)
          (apply orig-fun args)
        (let ((url (car args)))
          (or (browse-github-issue-url-with-forge url)
              (apply orig-fun args)))))
    (advice-add 'markdown--browse-url :around #'markdown-browse-github-issue-url-with-forge)
    ))

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package orgit :ensure t)
;(use-package orgit-forge :ensure t) ;; FIXME: error: Required package ‘forge-0.3’ is unavailable

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; FIXME: this seems broken: "funcall: Symbol’s function definition is void: closure"
;; FIXME: transient menu (M-x consult-gh) seems slow
;; FIXME: source code modified because not compatible with latest forge
;; -> wait until consult-gh is fixed upstream?
;; -> write own alternative for consult-gh-forge--issue-view?
;;    - consult-gh's implementation seems not straightforward
;; -> can i do with forge some of the things that you can do with ghi (like filtering issues)?
;;    - see https://github.com/magit/forge/issues/140
;; -> for now commented out line with forge--zap-repository-cache
;;    - works, but warning message "Obsolete value for ‘forge-get-repository’s DEMAND: ‘full’; use ‘:tracked?’ instead"
;;    - should commit and push to fork
;;    - not sure if this is correct
;(use-package consult-gh
;  :straight (consult-gh :type git :host github :repo "armindarvish/consult-gh" :fork t)
;  :bind (("C-c g h i" . consult-gh-issue-search)
;         ("C-c g h p" . consult-gh-pr-search))
;  :custom
;  (consult-gh-prioritize-local-folder t)
;  ;(consult-gh-show-preview t)
;  ;(consult-gh-preview-key "M-o")
;  ;(consult-gh-repo-action #'consult-gh--repo-browse-files-action)
;  (consult-gh-issue-action #'consult-gh-forge--issue-view-action)
;  (consult-gh-pr-action #'consult-gh-forge--pr-view-action)
;  ;(consult-gh-code-action #'consult-gh--code-view-action)
;  ;(consult-gh-file-action #'consult-gh--files-view-action)
;  ;(consult-gh-large-file-warning-threshold 2500000)
;  :config
;  (require 'consult-gh-transient)
;  (require 'forge)
;  (require 'consult-gh-forge)
;  (add-to-list 'consult-gh-default-orgs-list "bertfrees")
;  (setq consult-gh-default-orgs-list
;          (append consult-gh-default-orgs-list
;                  (remove "" (split-string (or (consult-gh--command-to-string "org" "list") "") "\n")))
;        consult-gh-default-clone-directory "~/src/github/")
;  ;; FIXME: omit last column (repo)
;  (defun consult-gh-issue-search (&optional repo query)
;    (interactive)
;    (let* ((default-repo (or repo (consult-gh--get-repo-from-directory)))
;           (repo (if (and default-repo (not current-prefix-arg))
;                     default-repo
;                   (format "%s" (car (consult-gh-search-repos default-repo t)))))
;           (query (or query (read-from-minibuffer (format "Search in %s issues: " (cadr (split-string repo "/"))))))
;           (query (if (or (= 0 (length query)) (string-match " " query)) (format "\"%s\"" query) query))
;           (query (format "%s -- --search %s" repo query))
;           (sel (consult-gh--async-issue-list "Search: " #'consult-gh--issue-list-builder query))
;           (sel (cons (car sel) (plist-put (cdr sel) :repo repo))))
;      (funcall consult-gh-issue-action sel)))
;  ;; FIXME: single command for issues and pull requests would be better
;  (defun consult-gh-pr-search (&optional repo query)
;    (interactive)
;    (let* ((default-repo (or repo (consult-gh--get-repo-from-directory)))
;           (repo (if (and default-repo (not current-prefix-arg))
;                     default-repo
;                   (format "%s" (car (consult-gh-search-repos default-repo t)))))
;           (query (or query (read-from-minibuffer (format "Search in %s PRs: " (cadr (split-string repo "/"))))))
;           (query (if (or (= 0 (length query)) (string-match " " query)) (format "\"%s\"" query) query))
;           (query (format "%s -- --search %s" repo query))
;           (sel (consult-gh--async-pr-list "Search: " #'consult-gh--pr-list-builder query))
;           (sel (cons (car sel) (plist-put (cdr sel) :repo repo))))
;      (funcall consult-gh-pr-action sel))))

#+END_SRC

** Org-mode

- [-] org-roam-ui: how to automatically find possible missings links?
  - nodes that are not directly related but also not completely unrelated will automatically be
    shown near each other
  - show nodes in graph during a node search?
    - e.g. would show nodes that have a common tag (even without actual links between the nodes)
    - by creating local graph and add nodes to it?
      #+BEGIN_SRC emacs-lisp
      (org-roam-ui-node-local "C1964180-E4BF-4D97-87E1-90E47274BFAA")
      (org-roam-ui-add-to-local-graph "C1964180-E4BF-4D97-87E1-90E47274BFAA")
      (org-roam-ui-add-to-local-graph "1F5CB692-216B-4F24-9897-1749442FDA15")
      #+END_SRC
      - makes nodes visible but nodes that are not related will not be shown close to each other:
        this is because all nodes are still connected via invisible edges and nodes
  - [X] follow selected node during a node search
    - could maybe be achieved by showing the buffer of the current selection during a node search
      - [X] use consult's live preview
      - unfortunately live preview is not followed
        - org-roam-ui--update-current-node uses org-roam-buffer-p and org-roam-id-at-point but the
          cursor is in the mini-buffer, not in the org buffer
        - [X] advise consult-org-roam--node-preview
- [ ] try org-ql
  - https://github.com/alphapapa/org-ql
- [ ] try org-roam-ql
- [-] try org-sidebar
  - https://github.com/alphapapa/org-sidebar
  - https://www.reddit.com/r/emacs/comments/jtydiy/who_needs_github_to_manage_a_project_when_you/
  - org-sidebar-tree-toggle
    - key binding?
    - how to automatically put navigation of current org file in fringe when switching buffer?
    - how to reduce width of fringe?
    - how to not expand everything in navigation pane?
    - annoying that a new buffer is created for every section (narrowed)
    - does it make things very slow?
- [ ] try org-rifle
  - also searches body
  - only searches agenda files or current org buffers
  - works best with few files with many nodes
- [ ] try org-super-agenda
  - https://github.com/alphapapa/org-super-agenda
- [X] try consult-org-roam
- [ ] try org-node
  - https://github.com/meedstrom/org-node
  - alternative for org-roam, but can work with it (same on-disk format)
  - better performance?
- [ ] try org-super-links
  - https://github.com/toshism/org-super-links
- [ ] try org-supertag
  - https://github.com/yibie/org-supertag
  - can work with org-roam
  - db-based (uses database that can not simply be generated from the text files)
- [ ] implement reminders via desktop notifications
  - https://www.youtube.com/watch?v=wKTKmE1wLyw

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t
  :commands (org-mode org-agenda org-capture org-store-link)
  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link))
  :config
  (set-face-attribute 'org-document-title nil ':height 1.00)
  (set-face-attribute 'org-drawer nil ':foreground "grey")
  (set-face-attribute 'org-meta-line nil ':foreground "grey")
  (setq org-directory "~/Dropbox/org"
        org-default-notes-file (expand-file-name "todo.org" org-directory)
        org-agenda-files
          `(,org-default-notes-file
            ,(expand-file-name "~/Dropbox/org/roam/agenda.org")
            ,(expand-file-name "~/Dropbox/org/roam/liblouis_work.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_daisy_consortium.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_sbs.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_dedicon.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_braille_autoriteit.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_luisterpuntbibliotheek.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/work_for_transkript.org")
            ,(expand-file-name "~/Dropbox/org/roam/betaalagenda.org")
            ,(expand-file-name "~/Dropbox/org/roam/vuilophaling.org")
            ,(expand-file-name "~/Dropbox/org/roam/kamerplanten.org")
            ,(expand-file-name "~/Dropbox/org/roam/ko_lab.org")
            ,(expand-file-name "~/Dropbox/org/roam/veilingen.org")
            ,(expand-file-name "~/Dropbox/org/roam/zaak/boekhouding.org")
            ,(expand-file-name "~/Dropbox/org/roam/daisy_pipeline/todo.org")
            ,(expand-file-name "~/Dropbox/org/roam/sbs/todo.org")
            ,(expand-file-name "~/Dropbox/org/roam/statped/todo.org")
            ;;,(expand-file-name "~/Dropbox/org/roam/atelier_in_beeld.org")
            ;; ,(expand-file-name "~/Dropbox/org/roam/luister_en_speur_naar_stadse_natuur.org")
            )
        org-startup-folded 'content
        org-cycle-include-plain-lists 'integrate
        org-drawers '("PROPERTIES" "LOGBOOK")
        ;; don't use hard indentation
        ;; (see also `org-remove-indentation-from-current-section' function below)
        org-adapt-indentation nil
        org-src-preserve-indentation t
        org-edit-src-content-indentation 0
        ;; soft indentation can be controlled with https://orgmode.org/manual/Org-Indent-Mode.html
        org-startup-indented t
        org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "DOING(d)" "|" "DONE(v)")
            (sequence "WAITING(w)" "HOLD(h)" "|" "CANCELLED(c)" "MISSED(m)"))
        org-fontify-done-headline nil
        org-todo-keyword-faces
          '(("TODO" :foreground "red" :weight bold)
            ("NEXT" :foreground "orange" :weight bold)
            ("DOING" :foreground "dodger blue" :weight bold)
            ("DONE" :foreground "lime green" :strike-through t :weight bold)
            ("WAITING" :foreground "red" :weight bold)
            ("HOLD" :foreground "red" :weight bold)
            ("CANCELLED" :foreground "purple" :strike-through t :weight bold)
            ("MISSED" :foreground "purple" :strike-through t :weight bold))
        org-hidden-keywords '(title)
        org-clock-history-length 25
        org-clock-in-switch-to-state 'org-clock-in-switch-to-doing
        org-clock-into-drawer t
        org-clock-out-remove-zero-time-clocks t
        org-clock-out-when-done t
        org-clock-auto-clock-resolution 'when-no-clock-is-running
        org-clock-persist t
        org-clock-report-include-clocking-task t
        org-time-stamp-rounding-minutes '(1 1)
        org-duration-format 'h:mm
        org-agenda-dim-blocked-tasks nil
        org-agenda-compact-blocks t
        org-agenda-span 'week
        org-agenda-log-mode-items '(closed state)
        org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2)
        org-agenda-clock-consistency-checks ;; werken niet meer
          '(:max-duration "10:00"
            :min-duration 0
            :max-gap "0:15"
            :gap-ok-around ("12:30" "13:00" "17:30" "18:00" "4:00")
            :default-face ((:background "orange") (:foreground "black"))
            :overlap-face ((:background "red") (:foreground "white"))
            :gap-face nil
            :no-end-time-face nil
            :long-face nil
            :short-face nil)
        org-agenda-window-setup 'current-window
        org-agenda-tags-column -120
        org-agenda-custom-commands
          '((" " "Agenda"
             ((agenda "" ((org-agenda-span 'day)
                          (org-agenda-prefix-format " %i %?-12t% s")
                          (org-agenda-remove-tags t)))
              nil))))
  ;; appointment reminders
  (add-hook 'org-agenda-finalize-hook
            (lambda () (org-agenda-to-appt)))
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (clojure . t)
      (shell . t)
      (dot . t) ;; brew install graphviz
      ;;(ledger . t)
      ))
  ;; this is a hack to evaluate code blocks using a simple Clojure CLI
  (setq org-babel-clojure-backend 'babashka
        ob-clojure-babashka-command "/Users/bert/bin/clojure")
  ;; FIXME: modify org-babel-expand-body:clojure so that it doesn't remove comments
  ;; (it does so because comments supposedly break let bindings)
  (defun org-babel-expand-body:clojure (body params)
    (let* ((vars (org-babel--get-vars params))
           (backend-override (cdr (assq :backend params)))
           (org-babel-clojure-backend
            (cond
             (backend-override (intern backend-override))
             (org-babel-clojure-backend org-babel-clojure-backend)
             (t (user-error "You need to customize `org-babel-clojure-backend'
or set the `:backend' header argument"))))
           (ns (or (cdr (assq :ns params))
                   (if (eq org-babel-clojure-backend 'cider)
                       (or cider-buffer-ns
                           (let ((repl-buf (cider-current-connection)))
                             (and repl-buf (buffer-local-value
                                            'cider-buffer-ns repl-buf))))
                     org-babel-clojure-default-ns)))
           (result-params (cdr (assq :result-params params)))
           (print-level nil)
           (print-length nil)
           ;; Remove comments, they break (let [...] ...) bindings
           ;;(body (replace-regexp-in-string "^[      ]*;+.*$" "" body))
           (body (org-trim
                  (concat
                   ;; Source block specified namespace :ns.
                   (and (cdr (assq :ns params)) (format "(ns %s)\n" ns))
                   ;; Variables binding.
                   (if (null vars) (org-trim body)
                     (format "(let [%s]\n%s)"
                             (mapconcat
                              (lambda (var)
                                (format "%S '%S" (car var) (cdr var)))
                              vars
                              "\n      ")
                             body))))))
      (if (or (member "code" result-params)
              (member "pp" result-params))
          (format "(clojure.pprint/pprint (do %s))" body)
        body)))
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
  (defun org-github-issue-link-open-with-forge (orig-fun &rest args)
    (if (not current-prefix-arg)
        (apply orig-fun args)
      (let* ((link (car args))
             (type (org-element-property :type link))
             (path (org-element-property :path link))
             (url (concat type ":" path)))
        (or (browse-github-issue-url-with-forge url)
            (apply orig-fun args)))))
  (advice-add 'org-link-open :around #'org-github-issue-link-open-with-forge)
  (defun org-clock-in-switch-to-doing (kw)
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (when (member (org-get-todo-state) '("TODO" "NEXT"))
        "DOING")))
  (add-hook 'org-mode-hook (lambda () (setq fill-column 100)))
  (defun org-timestamp-at-point-as-utc-time ()
    (interactive)
    (when (org-at-timestamp-p 'lax)
      (message "%s"
               (format-time-string "%H:%M UTC"
                                   (org-time-string-to-time
                                    (apply 'buffer-substring
                                           (flatten-tree (org-in-regexp org-ts-regexp3))))
                                   t))))
  ;; export agendas to ics
  (defun export-agenda-on-save ()
    (interactive)
    (when (and (eq major-mode 'org-mode)
               (string= (buffer-file-name) "/Users/bert/Dropbox/org/roam/agenda_hoveniersstraat_14.org"))
      (let ((outfile "/Users/bert/Dropbox/public/agenda_hoveniersstraat_14.ics"))
        (org-export-to-file 'icalendar outfile
          nil nil nil nil
          '(:ascii-charset utf-8 :ascii-links-to-notes nil)
          (lambda (file)
            (run-hook-with-args 'org-icalendar-after-save-hook file) nil)))))
  (add-hook 'after-save-hook 'export-agenda-on-save)

  (use-package org-indent
    :config
    (set-face-attribute 'org-indent nil ':background "#e0f4ff"))
  ;; https://github.com/jkitchin/ox-clip
  ;; - FIXME: retain styles
  ;; - FIXME: copy to clipboard does not work
  ;; => alternatives
  ;;    - https://github.com/Lindydancer/highlight2clipboard
  ;;    - https://speechcode.com/blog/org-to-clipboard
  ;;    - https://www.reddit.com/r/orgmode/comments/ge24ny/orgtoclipboard/
  ;;    - (funcall interprogram-cut-function (org-html-htmlize-region-for-paste (region-beginning) (region-end)))
  ;;      - does not include collapsed content
  ;;      - FIXME: this uses htmlize, not org export: may be less useful for pasting in email
  ;;      - FIXME: will include selection highlighting if region is selected
  ;;      - FIXME: can not paste directly, need to first paste in html file, open html file, and copy
  ;;        - use osascript to copy as HTML?
  ;;          - but will not work with mosh
  (use-package ox-clip
    :ensure t
    :commands (ox-clip-formatted-copy))
  ;; enabled old easy template system
  ;; <s = SRC
  ;; <e = EXAMPLE
  ;; <q = QUOTE
  ;; (the new preferred method to add a src, example and quote is through org-insert-structure-template, bound to C-c C-,)
  ;; first edit org-structure-template-alist in order to make the templates uppercase
  (setq org-structure-template-alist nil) ;; FIXME: this is a workaround for "Warning (emacs): Duplicated keys in
                                          ;; ‘org-structure-template-alist’ and ‘org-tempo-keywords-alist’"
  (add-to-list 'org-structure-template-alist '("s" . "SRC"))
  (add-to-list 'org-structure-template-alist '("e" . "EXAMPLE"))
  (add-to-list 'org-structure-template-alist '("q" . "QUOTE"))
  (require 'org-tempo))

;(use-package emacsql-sqlite-builtin
;  :ensure t)

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package org-roam
  :ensure t
  :defer 300 ;; ~ same as (run-with-idle-timer 300 nil #'org-roam-db-autosync-enable)
  :after emacsql-sqlite-builtin ;; see https://org-roam.discourse.group/t/org-roam-fails-with-selecting-deleted-buffer-error/3353/9
  :commands (org-roam-capture
             org-roam-buffer-toggle)
  :autoload (org-roam-node-find
             org-roam-node-insert)
  :bind (("C-c n f" . org-roam-node-find-with-vertico)
         ("C-c n i" . org-roam-node-insert-with-vertico)
         ("C-c n c" . org-roam-capture)
         ("C-c n l" . org-roam-buffer-toggle))
  :config
  (require 'org-roam-node)
  (cl-defmethod org-roam-node-title-with-hierarchy ((node org-roam-node))
    (let ((title (org-roam-node-title node)))
      (if (> (org-roam-node-level node) 0)
        (let* ((file-title (org-roam-node-file-title node))
               (file-title (if (string= "" file-title) nil (list file-title)))
               (outline-path (org-roam-node-olp node)))
          (string-join (append '() file-title outline-path (list title)) " > "))
        title)))
  (setq org-roam-v2-ack t
        ;; FIXME: why not use ~/Dropbox/org instead of ~/Dropbox/org/roam?
        ;; => probably because it takes longer
        ;; FIXME: why not use my home directory as the base directory for roam?
        ;; => because it takes even longer
        ;; => because new notes won't be backed up unless I can somehow say that they need to be put under ~/Dropbox/org
        org-roam-directory "~/Dropbox/org/roam"
        org-roam-node-display-template "${title-with-hierarchy:*} ${tags:0} ${refs:0}" ;; include tags in search but don't show them
        org-roam-capture-templates
        '(("d" "default" plain
           "%?"
           ;; FIXME: how to add :ROAM_REFS: in property drawer?
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+FILETAGS:\n#+TITLE: ${title}\n")
           :unnarrowed t)))
  ;; FIXME: is this needed and why?
  ;; => shouldn't this be done automatically?
  ;; => sometimes causes error, after which i need to do a M-x org-roam-db-sync
  ;; => there is also a org-roam-update-org-id-locations function
  ;(org-id-update-id-locations (directory-files-recursively org-roam-directory ".org$\\|.org.gpg$"))
  (org-roam-db-autosync-enable)
  ;; FIXME: *org-roam* buffer is not automatically updated when it is in another frame
  ;(add-to-list 'display-buffer-alist
  ;             '("\\*org-roam\\*"
  ;               display-buffer-pop-up-frame))
  (define-key org-roam-mode-map [mouse-1] #'org-roam-buffer-visit-thing)
  )

;; note that this is the default behavior of org-roam-node-find if vertico-mode is
; enabled, however vertico-mode is not enabled by default because it has issues (see below)
(defun org-roam-node-find-with-vertico ()
  (interactive)
  (if vertico-mode
      (org-roam-node-find)
    (unwind-protect
        (progn
          (vertico-mode +1)
          (org-roam-node-find))
      (vertico-mode -1))))
(defun org-roam-node-insert-with-vertico ()
  (interactive)
  (if vertico-mode
      (org-roam-node-insert)
    (unwind-protect
        (progn
          (vertico-mode +1)
          (org-roam-node-insert))
      (vertico-mode -1))))

(global-set-key (kbd "C-c n f") 'org-roam-node-find-with-vertico)
(global-set-key (kbd "C-c n i") 'org-roam-node-insert-with-vertico)
(global-set-key (kbd "C-c n c") 'org-roam-capture)
(global-set-key (kbd "C-c n l") 'org-roam-buffer-toggle)

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package org-roam-ql
  :ensure t
  :after org-roam
  :bind ((:map org-roam-mode-map
         ("v" . org-roam-ql-buffer-dispatch)
         ;:map minibuffer-mode-map
         ;("C-c n i" . org-roam-ql-insert-node-title)
         )))

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package org-roam-ui
  :ensure t
  :after org-roam
  :bind (("C-c n u i" . org-roam-ui-open))
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        ;; if `org-roam-ui-open-on-start' is set to t, org-roam-ui-open will open two tabs,
        ;; and when one tab is closed, org-roam-ui-follow-mode is automatically disabled
        org-roam-ui-open-on-start nil))

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; FIXME: preview is very annoying for org-roam-node-insert (only when linking to same file)
(use-package consult-org-roam
  :ensure t
  :after org-roam
  :init
  (require 'consult-org-roam)
  (consult-org-roam-mode 1)
  ;; FIXME: why does this not seem to make use of org-roam-node-title-with-hierarchy?
  ;; => does it not check org-roam-node-display-template?
  ;; => but consult-org-roam-ui-follow-node-preview still seems to called even though
  ;;    consult-org-roam-file-find isn't?
  :config
  (defun consult-org-roam-ui-follow-node-preview (orig-fun &rest args)
    (require 'cl) ;; needed for lexical-let (FIXME: deprecated)
    (lexical-let ((fun (apply orig-fun args)))
      (when fun
        (lambda (action cand)
          (when (org-roam-node-p cand)
            (require 'org-roam-ui)
            (when (websocket-openp org-roam-ui-ws-socket)
              (let ((node (org-roam-node-id cand)))
                (unless (string= org-roam-ui--ws-current-node node)
                  (setq org-roam-ui--ws-current-node node)
                  (websocket-send-text org-roam-ui-ws-socket
                                       (json-encode `((type . "command")
                                                      (data . ((commandName . "follow")
                                                               (id . ,node)))))))))
              (funcall fun action cand))))))
  (advice-add 'consult-org-roam--node-preview :around #'consult-org-roam-ui-follow-node-preview))

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; required external tools: gh, jq
(use-package om-dash
  :straight (om-dash :type git
                     :host github
                     :repo "gavv/om-dash"
                     :branch "main"
                     :files ("om-dash.el")))

#+END_SRC

Function to automatically make nodes of headings that are being linked to:

#+NAME: config
#+BEGIN_SRC emacs-lisp
(defun org-convert-next-link-to-id-link ()
  (interactive)
  (let ((next-link)
        (org-link--search-failed nil)
        (org-roam-directory (concat (expand-file-name org-roam-directory) "/")))
    (while (and (not next-link)
                (not org-link--search-failed))
      (org-next-link)
      (let* ((link (org-element-context))
             (raw-link (org-element-property :raw-link link))
             (type (org-element-property :type link))
             (file (org-element-property :path link)))
        (when (or (s-starts-with? "*" raw-link) ;; (require 's)
                  (and (string= type "file")
                       (s-ends-with? ".org" file)
                       (or
                        ;; broken link is reported below
                        (not (file-exists-p file))
                        ;; ignore org files that are not inside org-roam-directory
                        (s-starts-with? org-roam-directory (expand-file-name file)))))
          (setq next-link link))))
    (when next-link
      (when-let ((id (if (and (string= (org-element-property :type next-link) "file")
                              (not (file-exists-p (org-element-property :path next-link))))
                         (progn (message "Broken link") nil)
                       (save-window-excursion
                         (save-excursion
                           (let ((org-link-search-must-match-exact-headline t))
                             (condition-case nil
                                 (progn (org-open-at-point)
                                        (org-id-get-create))
                               (error (progn (message "Broken link") nil)))))))))
        (insert "[[id:")
        (insert id)
        (insert "]")
        (delete-forward-char 1)
        (when (org-element-property :contents-begin next-link)
          (zap-to-char 1 ?\]))
        (message "id:%s" id)))))
(global-set-key (kbd "C-x l") 'org-convert-next-link-to-id-link)

#+END_SRC

Function to automatically strip hard indentation:

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; make sure that the the current section heading is visible, as well as the
;; next (if this is not the case the script will have no effect)
(defun org-remove-indentation-from-current-section ()
  (interactive)
  (save-excursion
    (if (org-at-heading-p)
        (beginning-of-line)
      (org-previous-visible-heading 1))
    (end-of-line)
    (forward-char)
    (when (not (org-at-heading-p))
      (cl-flet ((unindent (start end)
                  (goto-char start)
                  (let ((content (buffer-substring (point) end)))
                    (delete-region (point) end)
                    (insert (org-remove-indentation content)))))
        (while (let* ((element (org-element-at-point))
                      (type (org-element-type element))
                      (drawer-name (org-element-property :drawer-name element)))
                 (cond ((string= type "property-drawer")
                        (progn
                          (save-excursion
                            (unindent (point) (org-element-property :end element)))
                          (goto-char (org-element-property :end (org-element-at-point)))
                          t))
                       ((and (string= type "drawer")
                             (string= drawer-name "LOGBOOK"))
                        (progn
                          (save-excursion
                            (unindent (point) (org-element-property :end element)))
                          (goto-char (org-element-property :end (org-element-at-point)))
                          t))
                       (t nil))))
        (let ((start-of-next-section (save-excursion
                                       (org-next-visible-heading 1)
                                       (point))))
          (unindent (point) start-of-next-section))))))
(global-set-key (kbd "C-x <") 'org-remove-indentation-from-current-section)

#+END_SRC

Below is a function to extract a node into a separate file. The contents are replaced by a link to
the new file. In case a logbook is present, it is kept in the original section. If desired, the
original section may be removed manually.

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; FIXME: does not work when there is no following headline on the same level!
;; FIXME: abort if any subsections have a logbook or deadline AND are NOT a node
;; - so that these subsections could first be made into nodes (and possibly extracted)
;; - alternative is that some subsections will not link to a node
(defun org-roam-extract-subtree-to-relative-file (orig-fun &rest args)
  (when-let ((id (or (org-id-get)
                     (progn (message "Not a node") nil))))
    (when-let ((node (or (org-roam-node-from-id id)
                         (progn (message "Not a node") nil))))
      (if (org-at-heading-p)
          (beginning-of-line)
        (org-previous-visible-heading 1))
      (let* ((begin (point))
             (headline (org-element-at-point))
             (end (org-element-property :end headline))
             (level (org-element-property :level headline))
             (todo (org-element-property :todo-keyword headline))
             (title (org-element-property :raw-value headline))
             (orig-content (buffer-substring begin end))
             (new-content
              (let ((new-content-buffer (generate-new-buffer " *temp*" t)))
                (unwind-protect
                    (progn
                      (with-current-buffer new-content-buffer
                        (dotimes (_ level) (insert "*"))
                        (insert " ")
                        (when todo
                          (insert (substring-no-properties todo) " "))
                        ;; FIXME: what if title is already a link?
                        (insert "[[id:" id "][" title "]]\n"))
                      (end-of-line)
                      (forward-char)
                      (while (let* ((element (org-element-at-point))
                                    (type (org-element-type element)))
                               (cond (;; stop at the next headline that is not a subsection
                                      (and (string= type "headline")
                                           (not (> (org-element-property :level element) level)))
                                      nil)
                                     (;; keep deadline and logbook only in original
                                      (or (and (string= type "drawer")
                                               (string= (org-element-property :drawer-name element)
                                                        "LOGBOOK"))
                                          (string= type "planning"))
                                      (let* ((begin (point))
                                             (end (org-element-property :end element))
                                             (content (buffer-substring begin end)))
                                        (delete-region begin end)
                                        (with-current-buffer new-content-buffer
                                          (insert content))
                                        t))
                                     (;; keep sub-headlines in original
                                      (string= type "headline")
                                      (progn
                                        (let ((id (org-id-get)))
                                          (with-current-buffer new-content-buffer
                                            (dotimes (_ (org-element-property :level element)) (insert "*"))
                                            (insert " ")
                                            (when-let ((todo (org-element-property :todo-keyword element)))
                                              (insert (substring-no-properties todo) " "))
                                            (when id
                                              ;; FIXME: what if title is already a link?
                                              (insert "[[id:" id "]["))
                                            (insert (org-element-property :title element))
                                            (when id
                                              (insert "]]"))
                                            (insert "\n")))
                                        (end-of-line)
                                        (forward-char)
                                        t))
                                     (;; keep everything else only in file
                                      (string= type "property-drawer")
                                      ;; FIXME: don't assume that ID is the only property!!
                                      (progn
                                        (goto-char (org-element-property :end element))
                                        t))
                                     (t (condition-case err
                                            (org-forward-element)
                                          (user-error nil))))))
                      (with-current-buffer new-content-buffer
                        (buffer-string)))
                  (and (buffer-name new-content-buffer)
                       (kill-buffer new-content-buffer))))))
        (goto-char begin)
        (let ((inhibit-quit t))
          (unless (with-local-quit
                    (let* ((current-dir (file-name-directory (buffer-file-name)))
                           ;(org-roam-extract-new-file-path "%<%Y%m%d%H%M%S>-${slug}.org")
                           (org-roam-directory current-dir))
                      ;; FIXME: the (save-buffer) at the beginning and end take a long time
                      ;; => but only because daisy_pipeline/todo.org is such a huge file: could
                      ;;    perhaps be worked around by temporarily splitting the file into
                      ;;    somewhat smaller parts
                      (apply orig-fun args)
                      t))
            (setq quit-flag nil)))
        (if (not (string= id (org-id-get)))
            ;; when the subtree was extracted, insert the new content
            (progn
              (insert new-content)
              (org-roam-node-visit (org-roam-node-from-id id) t)
              (beginning-of-buffer)
              (re-search-forward "#\\+title:")
              (beginning-of-line)
              ;; FIXME: also insert :ROAM_REFS:
              (insert "#+FILETAGS:\n")
              (backward-char))
          ;; otherwise restore the original content
          (delete-region (point) (org-element-property :end (org-element-at-point)))
          (insert orig-content))))))
(advice-add 'org-roam-extract-subtree :around #'org-roam-extract-subtree-to-relative-file)
(global-set-key (kbd "C-c n x") 'org-roam-extract-subtree)

#+END_SRC

- [ ] Function to replace a node with another one (let all nodes that point to it, point to the other node)
- [ ] Function to capture a Github issue as a note
- [ ] Replace all "gh:" links with real links to Github
  - but first make sure that I can still do what I used to be able to with the gh: links (see MacBook)
- [ ] Function to replace a Github link that corresponds with a note to a link to that note
- [ ] Function to help eliminate unneeded explicit backlinks (e.g. from actual notes to clock items)

** Selection, completion, navigation, key binding

- [ ] try embark!
  - https://github.com/oantolin/embark
- [ ] do i still need helm?
- [X] try consult
- [X] try vertico
  - https://github.com/minad/vertico
- [X] try marginalia
  - https://github.com/minad/marginalia
- [ ] try bufler?
  - https://github.com/alphapapa/bufler.el

*** Auto-complete

Auto-completion framework used by nxml-mode and mu4e.

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package auto-complete
  :ensure t
  :commands auto-complete-mode
  :config
  (setq-default ac-sources '())
  (setq ac-auto-start nil
        ac-dwim t
        ac-ignore-case t
        ac-menu-height 10
        ac-quick-help-prefer-pos-tip t
        ac-use-quick-help t
        ac-quick-help-height 20
        ac-quick-help-delay 1
        ac-use-comphist nil)
  (ac-set-trigger-key "TAB"))

#+END_SRC

*** Company

Auto-completion framework used by lsp-mode.

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :bind (:map company-active-map
              ("<tab>" . company-complete-selection))
  :custom
  (company-minimum-prefix-length 1)
  (company-idle-delay 0.0)
  :config
  ;; hack to only trigger completion on TAB
  (setq company-minimum-prefix-length 100)
  ;; don't show white space characters in company menu
  (set-default 'whitespace-mode nil)
  (set-default 'saved-whitespace-mode nil)
  (defun company-disable-whitespace-mode (_)
    (make-local-variable 'saved-whitespace-mode)
    (if (or whitespace-mode saved-whitespace-mode)
        (progn (setq saved-whitespace-mode t)
               ;; disabling whitespace-mode with `(whitespace-mode -1)', or hiding the
               ;; characters with `(whitespace-display-char-off)', does not work in some
               ;; modes, therefore use this hack
               (setq buffer-display-table nil))
      (setq saved-whitespace-mode nil)))
  (defun company-restore-whitespace-mode (_)
    (make-local-variable 'saved-whitespace-mode)
    (when saved-whitespace-mode
      (whitespace-mode 1)
      (setq saved-whitespace-mode nil)))
  (add-hook 'company-completion-started-hook #'company-disable-whitespace-mode)
  (add-hook 'company-after-completion-hook #'company-restore-whitespace-mode))

#+END_SRC

*** Vertico

- [ ] don't use vertico-mode for rgrep
  - or configure it so that you don't have to choose one of the options
- [ ] don't use vertico-mode for save to file

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package vertico
  :ensure t
  :init
  ;;(vertico-mode)

  ;; Different scroll margin
  ;; (setq vertico-scroll-margin 0)

  ;; Show more candidates
  ;; (setq vertico-count 20)

  ;; Grow and shrink the Vertico minibuffer
  ;; (setq vertico-resize t)

  ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
  ;; (setq vertico-cycle t)
  )

#+END_SRC

*** Orderless

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))

#+END_SRC

*** Marginalia

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  :ensure t
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  :bind (:map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init section is always executed.
  :init

  ;; Marginalia must be activated in the :init section of use-package such that
  ;; the mode gets enabled right away. Note that this forces loading the
  ;; package.
  (marginalia-mode))

#+END_SRC

*** Consult

- [ ] show column with title for forge topics

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package consult
  :ensure t
  :bind (;; FIXME: special commands to filter buffers
         ;; - C-x c t b: vterm buffers
         ;; - C-x c o b: org-mode buffers (note that org-roam buffer already have a dedicated section
         ;;                                thanks to consult-org-roam)
         ;; - ...
         ("C-x c b" . consult-buffer)
         
         ;; see also https://github.com/minad/consult#configuration:
         
         ;;; C-c bindings in `mode-specific-map'
         ;("C-c M-x" . consult-mode-command)
         ;("C-c h" . consult-history)
         ;("C-c k" . consult-kmacro)
         ;("C-c m" . consult-man)
         ;("C-c i" . consult-info)
         ;([remap Info-search] . consult-info)
         ;;; C-x bindings in `ctl-x-map'
         ;("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ;("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ;("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ;("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ;("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ;("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;;; Custom M-# bindings for fast register access
         ;("M-#" . consult-register-load)
         ;("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ;("C-M-#" . consult-register)
         ;;; Other custom bindings
         ;("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;;; M-g bindings in `goto-map'
         ;("M-g e" . consult-compile-error)
         ;("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ;("M-g g" . consult-goto-line)             ;; orig. goto-line
         ;("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ;("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ;("M-g m" . consult-mark)
         ;("M-g k" . consult-global-mark)
         ;("M-g i" . consult-imenu)
         ;("M-g I" . consult-imenu-multi)
         ;;; M-s bindings in `search-map'
         ;("M-s d" . consult-find)                  ;; Alternative: consult-fd
         ;("M-s c" . consult-locate)
         ;("M-s g" . consult-grep)
         ;("M-s G" . consult-git-grep)
         ;("M-s r" . consult-ripgrep)
         ;("M-s l" . consult-line)
         ;("M-s L" . consult-line-multi)
         ;("M-s k" . consult-keep-lines)
         ;("M-s u" . consult-focus-lines)
         ;;; Isearch integration
         ;("M-s e" . consult-isearch-history)
         ;:map isearch-mode-map
         ;("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ;("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ;("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ;("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;;; Minibuffer history
         ;:map minibuffer-local-map
         ;("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ;("M-r" . consult-history)                 ;; orig. previous-matching-history-element
         )
  :config
  
  ;; FIXME: remove buffer from list after killed and move to next buffer in list
  (defun consult-kill-original-window-buffer ()
    (interactive)
    (kill-buffer (window-buffer (consult--original-window))))
  (defun consult-buffer-bind-kill-buffer (orig-fun &rest args)
    (unwind-protect
        (progn
          (keymap-set minibuffer-local-map "C-d" 'consult-kill-original-window-buffer)
          (apply orig-fun args))
      (keymap-set minibuffer-local-map "C-d" 'delete-char)))
  (advice-add 'consult-buffer :around #'consult-buffer-bind-kill-buffer)
  
  ;; see also https://github.com/minad/consult#configuration:
  
  ;;; Enable automatic preview at point in the *Completions* buffer. This is
  ;;; relevant when you use the default completion UI.
  ;:hook (completion-list-mode . consult-preview-at-point-mode)
  ;
  ;;; The :init configuration is always executed (Not lazy)
  ;:init
  ;
  ;;; Optionally configure the register formatting. This improves the register
  ;;; preview for `consult-register', `consult-register-load',
  ;;; `consult-register-store' and the Emacs built-ins.
  ;(setq register-preview-delay 0.5
  ;      register-preview-function #'consult-register-format)
  ;
  ;;; Optionally tweak the register preview window.
  ;;; This adds thin lines, sorting and hides the mode line of the window.
  ;(advice-add #'register-preview :override #'consult-register-window)
  ;
  ;;; Use Consult to select xref locations with preview
  ;(setq xref-show-xrefs-function #'consult-xref
  ;      xref-show-definitions-function #'consult-xref)
  ;
  ;;; Configure other variables and modes in the :config section,
  ;;; after lazily loading the package.
  ;:config
  ;
  ;;; Optionally configure preview. The default value
  ;;; is 'any, such that any key triggers the preview.
  ;;; (setq consult-preview-key 'any)
  ;;; (setq consult-preview-key "M-.")
  ;;; (setq consult-preview-key '("S-<down>" "S-<up>"))
  ;;; For some commands and buffer sources it is useful to configure the
  ;;; :preview-key on a per-command basis using the `consult-customize' macro.
  ;(consult-customize
  ; consult-theme :preview-key '(:debounce 0.2 any)
  ; consult-ripgrep consult-git-grep consult-grep
  ; consult-bookmark consult-recent-file consult-xref
  ; consult--source-bookmark consult--source-file-register
  ; consult--source-recent-file consult--source-project-recent-file
  ; ;; :preview-key "M-."
  ; :preview-key '(:debounce 0.4 any))
  ;
  ;;; Optionally configure the narrowing key.
  ;;; Both < and C-+ work reasonably well.
  ;(setq consult-narrow-key "<") ;; "C-+"
  ;
  ;;; Optionally make narrowing help available in the minibuffer.
  ;;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)
  ;
  ;;; By default `consult-project-function' uses `project-root' from project.el.
  ;;; Optionally configure a different project root function.
  ;;;;; 1. project.el (the default)
  ;;; (setq consult-project-function #'consult--default-project--function)
  ;;;;; 2. vc.el (vc-root-dir)
  ;;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;;; 3. locate-dominating-file
  ;;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  ;;;;; 4. projectile.el (projectile-project-root)
  ;;; (autoload 'projectile-project-root "projectile")
  ;;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;;; 5. No project support
  ;;; (setq consult-project-function nil)
  )

#+END_SRC

*** Ido

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package ido
  :config
  (setq ido-enable-prefix nil
        ido-enable-flex-matching t
        ido-create-new-buffer 'always
        ido-use-filename-at-point 'guess
        ido-max-prospects 10
        ido-default-file-method 'selected-window
        ido-everywhere t)
  :bind
  (("M-x" . (lambda ()
              (interactive)
              (call-interactively
               (intern
                (ido-completing-read
                 "M-x "
                 (all-completions "" obarray 'commandp)
                 'commandp t nil 'extended-command-history
                 (car extended-command-history))))))
   ;; in addition to the default C-x b, because I often type C-x C-b by accident
   ("C-x C-b" . 'ido-switch-buffer)))

(ido-mode t)

#+END_SRC

*** Ivy

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :autoload ivy-mode)

#+END_SRC

*** Find File at Point

Find File at Point (ffap) is a built-in Emacs library that other tools such as Ido makes use of.

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package ffap
  :config
  ;; adapted from https://www.emacswiki.org/emacs/FindFileAtPoint:
  (defvar ffap-file-at-point-line-number nil
    "Variable to hold line number from the last `ffap-file-at-point' call.")
  ;; add `[', `]' and `,' to list of characters to include in (ffap-string-at-point)
  (add-to-list 'ffap-string-at-point-mode-alist '(file "--:\\\\${}+<>@-Z_[:alpha:]~*?[]," "{<@" "@>;.,!:}"))
  (defadvice ffap-file-at-point (after ffap-store-line-number activate)
    "Search `ffap-string-at-point' for a line number pattern and
save it in `ffap-file-at-point-line-number' variable."
    (let* ((string (ffap-string-at-point))
           (name
            (or (condition-case nil
                    (and (not (string-match "//" string)) ; foo.com://bar
                         (substitute-in-file-name string))
                  (error nil))
                string))
           (line-number-string
            (and (string-match ":\\(\\([0-9]+\\)\\|\\[\\([0-9]+\\),[0-9]+\\]\\)" name) ; `:line' or `:line:' or `:[line,column]'
                                                                                       ; (but note that the first : after files in rgrep
                                                                                       ; window is actually a ^@)
                 (concat
                  (match-string 2 name)
                  (match-string 3 name))))
           (line-number
            (and line-number-string
                 (string-to-number line-number-string))))
      (if (and line-number (> line-number 0))
          (setq ffap-file-at-point-line-number line-number)
        (setq ffap-file-at-point-line-number nil))))
  (defadvice find-file-at-point (after ffap-goto-line-number activate)
    "If `ffap-file-at-point-line-number' is non-nil goto this line."
    (when ffap-file-at-point-line-number
      (goto-line ffap-file-at-point-line-number)
      (setq ffap-file-at-point-line-number nil)))
  (defadvice ido-find-file (after ido-goto-line-number activate)
    "If `ffap-file-at-point-line-number' is non-nil goto this line."
    (when ffap-file-at-point-line-number
      (goto-line ffap-file-at-point-line-number)
      (setq ffap-file-at-point-line-number nil))))

#+END_SRC

*** Treemacs

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package treemacs :ensure t)

#+END_SRC

*** Hydra

Tie related commands into a family of short bindings with a common prefix See
https://github.com/abo-abo/hydra.

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)

#+END_SRC

*** which-key

- [ ] drop if it is included in Emacs (likely in v30)

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode)
  (which-key-setup-side-window-bottom)
  ;;(which-key-setup-minibuffer)
  )

#+END_SRC

*** Evil

Vim key bindings

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :config
  (setq evil-default-state 'emacs)
  (evil-set-initial-state 'undo-tree-visualizer-mode 'emacs)
  ;; make it more obvious that we are in evil-mode and whether we are in insert or normal mode
  (use-package vi-tilde-fringe :ensure t)
  (setq-default display-line-numbers nil
                display-line-numbers-widen t
                display-line-numbers-current-absolute t)
  (add-hook 'evil-insert-state-entry-hook (lambda ()
                                            (setq-local display-line-numbers 'visual)
                                            (vi-tilde-fringe-mode +1)))
  (add-hook 'evil-normal-state-entry-hook (lambda ()
                                            (setq-local display-line-numbers t)
                                            (vi-tilde-fringe-mode +1)))
  (add-hook 'evil-emacs-state-entry-hook (lambda ()
                                           (setq-local display-line-numbers nil)
                                            (vi-tilde-fringe-mode -1)))
  (custom-set-faces '(line-number-current-line ((t :weight bold
                                                   :foreground "black"
                                                   :background "white")))))

(evil-mode 1)
#+END_SRC

** Cut & paste

- try [[https://github.com/spudlyo/clipetty][clipetty]] instead?

#+NAME: config
#+BEGIN_SRC emacs-lisp
(defun interprogram-killring-peek ()
  (let ((tramp-mode nil)
        (default-directory "~"))
    (shell-command-to-string "/usr/bin/pbpaste")))

(defun interprogram-killring-push (text &optional push)
  (let ((process-connection-type nil))
    (let ((proc (start-process "killring push" "*Messages*" "/usr/bin/pbcopy")))
      (process-send-string proc text)
      (process-send-eof proc))))

(setq save-interprogram-paste-before-kill t
      interprogram-cut-function 'interprogram-killring-push
      interprogram-paste-function 'interprogram-killring-peek)

#+END_SRC

** Email

- [ ] try consult-mu

#+NAME: config
#+BEGIN_SRC emacs-lisp
(setq user-mail-address "bertfrees@gmail.com"
      user-full-name "Bert Frees"
      mail-user-agent 'mu4e-user-agent)

(global-unset-key (kbd "C-x m"))

(use-package smtpmail
  :demand t
  :config
  (setq smtpmail-stream-type 'ssl
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 465)
  (use-package message
    :config
    (setq message-send-mail-function 'smtpmail-send-it
          message-kill-buffer-on-exit t
          message-signature nil)))

;; FIXME: don't stop *mu4e-update* process when mu4e is quit?
(use-package mu4e
  ;; every now and then, the version number needs to be updated
  ;; -> compute path with $(dir $(readlink -f /opt/homebrew/bin/mu)/../share/emacs/site-lisp/mu/mu4e
  ;; -> must match mu4e-mu-binary
  ;;:load-path "/opt/homebrew/Cellar/mu/1.12.4/share/emacs/site-lisp/mu/mu4e"
  :load-path "/opt/homebrew/Cellar/mu/1.12.9_2/share/emacs/site-lisp/mu/mu4e"
  :commands mu4e
  :bind ((("C-x m u"     . mu4e)
          ("C-x µ"       . mu4e)
          ("C-x m C"     . compose-mail))
         :map mu4e-headers-mode-map
         ("t"            . mu4e-headers-mark-for-tag)
         ("d"            . mu4e-headers-mark-for-tag-as-trash)
         ("<backspace>"  . mu4e-headers-mark-for-tag-as-trash)
         ("D"            . mu4e-headers-mark-for-delete-permanently)
         ("<delete>"     . mu4e-headers-mark-for-delete-permanently)
         ("<deletechar>" . mu4e-headers-mark-for-delete-permanently)
         ("*"            . mu4e-headers-mark-for-star)
         ("o"            . mu4e-headers-mark-for-unstar)
         ("a"            . mu4e-headers-mark-for-archive)
         ("i"            . mu4e-headers-mark-for-inbox)
         ("?"            . mu4e-headers-mark-for-unread)
         ("x"            . mu4e-mark-execute-all-no-confirmation)
         ("m"            . nil)
         ("+"            . nil)
         ("-"            . nil)
         :map mu4e-compose-minor-mode-map
         ("R"            . mu4e-compose-wide-reply)
         ("W"            . nil)
         :map mu4e-view-mode-map
         ("W"            . mu4e-view-show-in-thread)
         ("t"            . mu4e-view-mark-for-tag)
         ("d"            . mu4e-view-mark-for-tag-as-trash)
         ("<backspace>"  . mu4e-view-mark-for-tag-as-trash)
         ("D"            . mu4e-view-mark-for-delete-permanently)
         ("<delete>"     . mu4e-view-mark-for-delete-permanently)
         ("<deletechar>" . mu4e-view-mark-for-delete-permanently)
         ("a"            . mu4e-view-mark-for-archive)
         ("m"            . nil)
         ("+"            . nil)
         ("-"            . nil)
         ("C-c C-o"      . mu4e--view-browse-url-from-binding)
         :map mu4e-search-minor-mode-map
         ("/"            . mu4e-search-narrow-with-auto-complete)
         )
  :config
  (setq mu4e-mu-binary "/opt/homebrew/Cellar/mu/1.12.9_2/bin/mu"
        mu4e-get-mail-command "offlineimap"
        mu4e~update-buffer-height 10
        mu4e-hide-index-messages t
        mu4e-action-tags-header "X-Keywords"
        mu4e-trash-folder "/trash"
        mu4e-sent-folder "/sent"
        mu4e-drafts-folder "/drafts"
        mu4e-attachment-dir "~/Desktop"
        mu4e-sent-messages-behavior 'delete
        mu4e-decryption-policy 'ask
        mu4e-use-fancy-chars t
        mu4e-search-include-related nil
        mu4e-headers-show-threads t ;; FIXME: fold all threads by default? or key binding for mu4e-view-thread-fold-toggle-all?
        mu4e-headers-date-format "%d %b"
        mu4e-headers-time-format "%H:%M"
        mu4e-headers-fields '((:human-date . 7)
                              (:from . 25)
                              (:subject . 68)
                              (:tags))
        mu4e-confirm-quit nil)
  (defvar mailinglists-to-ignore '("accessibility@global.libreoffice.org" ;; FIXME: unsubscribe
                                   "transition-to-accessible-epub@mail.daisy.org"
                                   "xproc-dev@w3.org"))
  (setq gmail-labels '("Mailboxen"              ("bert.frees@sbs.ch"                             "#00BFFF"
                                                   "bfrees@daisy.org"                              "#00BFFF"
                                                   "bert@sonuwe.com"                               "#C39EF0"
                                                   "bertfrees@gmail.com"                           "#FFAC26"
                                                   "bertfrees@hotmail.com"                         "#FF6EC3"
                                                   "bertfrees@openoffice.org"                      nil
                                                   "bertfrees@users.sourceforge.net"               nil)
                         "Mailinglijsten"         ("brailleblaster@freelists.org"                  nil
                                                   "brailleutils@googlegroups.com"                 nil
                                                   "daisymfc-developer@lists.sourceforge.net"      "#0982B3"
                                                   "daisy-pipeline@mail.daisy.org"                 "#0982B3"
                                                   "daisy-pipeline-braille@googlegroups.com"       "#0982B3"
                                                   "daisy-pipeline-dev@googlegroups.com"           "#0982B3"
                                                   "ebraille@daisylists.org"                       "#58BAE0"
                                                   "liblouis-liblouisxml@freelists.org"            "#EBCC1E"
                                                   "libreoffice@lists.freedesktop.org"             nil
                                                   "odt2braille-develop@lists.sourceforge.net"     "#FF4000"
                                                   "technical-developments@mail.daisy.org"         nil
                                                   "transition-to-accessible-epub@mail.daisy.org"  nil
                                                   "xproc-dev@w3.org"                              nil)
                         "Tags"                   ("accessodf"                                     "#FF4000"
                                                   "ebraille"                                      "#58BAE0"
                                                   "jobs"                                          nil
                                                   "liblouis"                                      "#EBCC1E"
                                                   "odt2braille"                                   "#FF4000"
                                                   "odt2daisy"                                     nil
                                                   "pipeline"                                      "#0982B3"
                                                   "refile"                                        nil
                                                   "sbs"                                           "#00BFFF"
                                                   "snaekobbi"                                     "#23CC72"
                                                   "ties"                                          nil
                                                   "zaak"                                          nil)
                         "Github notifications"   (nil                                             nil)
                         "Archieven"              ("aegis"                                         nil
                                                   "alternate.textbooks@dsv.kuleuven.be"           nil
                                                   "bert.frees@esat.kuleuven.be"                   nil
                                                   "kuleuven"                                      nil)))
  (let ((face 'gmail-label-default-face))
    (make-face face)
    (set-face-attribute face nil ':slant 'italic)
    (set-face-attribute face nil ':foreground "#B0B0B0"))
  (require 'cl-lib)
  (cl-loop for (superlabel sublabels) on gmail-labels by #'cddr do
    (cl-loop for (sublabel colors) on sublabels by #'cddr do
      (let* ((label (if sublabel (concat superlabel "/" sublabel) superlabel))
             (face (intern (format "gmail-label-%s-face" (string-replace " " "-" label))))
             (foreground (if (listp colors) (car colors) colors))
             (background (if (listp colors) (cdr colors))))
        (make-face face)
        (set-face-attribute face nil ':weight 'bold)
        (set-face-attribute face nil ':foreground (or foreground "#B0B0B0"))
        (when background (set-face-attribute face nil ':background background)))))
  (setq mu4e-github-notifications-query
        "from:notifications@github.com AND maildir:/all AND NOT tag:\\\\Trash AND NOT tag:Github\\ Notifications/trash")
  (setq mu4e-bookmarks `(("tag:\\\\Inbox AND maildir:/all AND NOT tag:\\\\Trash"                             "Inbox"                ?i)
                         (,(concat "flag:unread AND maildir:/all AND NOT tag:\\\\Trash"
                                   " AND NOT tag:Github\\ notifications/trash"
                                   (string-join (mapcar (lambda (x) (concat " AND NOT tag:Mailinglijsten/" x))
                                                        mailinglists-to-ignore)
                                                ""))                                                         "Unread"               ?u)
                         (,mu4e-github-notifications-query                                                   "Github notifications" ?g)
                         (,(concat "maildir:/all AND NOT tag:\\\\Trash"
                                   " AND NOT tag:Github\\ Notifications/trash AND ("
                                   (string-join '("tag:Mailinglijsten/liblouis-liblouisxml@freelists.org"
                                                  "tag:Tags/liblouis")
                                                " OR ")
                                    ")")                                                                     "Liblouis"             ?l)
                         (,(concat "maildir:/all AND NOT tag:\\\\Trash"
                                   " AND NOT tag:Github\\ Notifications/trash AND ("
                                   (string-join '("tag:Mailinglijsten/daisy-pipeline-dev@googlegroups.com"
                                                   "tag:Mailinglijsten/daisy-pipeline@mail.daisy.org"
                                                   "tag:Tags/pipeline")
                                                 " OR ")
                                    ")")                                                                     "DAISY Pipeline"       ?p)
                         (,(concat "date:today..now AND maildir:/all AND NOT tag:\\\\Trash"
                                   " AND NOT tag:Github\\ Notifications/trash"
                                   (string-join (mapcar (lambda (x) (concat " AND NOT tag:Mailinglijsten/" x))
                                                        mailinglists-to-ignore)
                                                ""))                                                         "Today's messages"     ?t)
                         (,(concat "date:7d..now AND maildir:/all AND NOT tag:\\\\Trash"
                                   " AND NOT tag:Github\\ Notifications/trash"
                                   (string-join (mapcar (lambda (x) (concat " AND NOT tag:Mailinglijsten/" x))
                                                        mailinglists-to-ignore)
                                                ""))                                                         "Last 7 days"          ?w)
                         ("maildir:/sent OR tag:\\\\Sent"                                                    "Sent"                 ?s)
                         ("tag:\\\\Starred"                                                                  "Starred"              ?*)
                         ("maildir:/trash OR tag:\\\\Trash OR tag:Github\\ Notifications/trash"              "Trash"                ?d)))
  ;; check that all messages have tags
  (add-to-list 'mu4e-bookmarks
    (list (let (labels)
            (cl-loop for (superlabel sublabels) on gmail-labels by #'cddr do
              (cl-loop for sublabel in sublabels by #'cddr
                       unless (and (string= superlabel "Mailboxen")
                                   (not (member sublabel '("bert.frees@sbs.ch")))) do
                (add-to-list 'labels (if sublabel (concat superlabel "/" sublabel) superlabel) t)))
            (concat "maildir:/all AND NOT tag:\\\\Inbox AND NOT tag:\\\\Trash AND NOT tag:Github\\ notifications/trash"
                    (string-join (mapcar (lambda (x) (concat " AND NOT tag:" (string-replace " " "\\ " x)))
                                         labels) "")))
          "Untagged"
          ?-)
    t)
  ;; FIXME: recompute when refreshing (g) the headers buffer
  ;; -> using mu4e-search-hook instead of mu4e-search-bookmark-hook does not help
  ;; -> for now need to do ~b g~
  (add-hook 'mu4e-search-bookmark-hook #'mu4e-sync-github-notifications-before-search)
  (defun mu4e-sync-github-notifications-before-search (query)
    (when (string= query mu4e-github-notifications-query)
      (advice-add 'mu4e~headers-append-handler :around #'mu4e-headers-append-github-notifications)))
  (defun mu4e-headers-append-github-notifications (orig-fun msglst &rest args)
    (unwind-protect
      (progn
        (require 'forge)
        (forge-pull-notifications)
        (let* ((notifs (forge--ls-notifications 'done))
               (done (remq nil
                           (mapcar (lambda (notif)
                                     (with-slots (url) notif
                                       (when (string-match "^https://api.github.com/repos/\\([^/]+/[^/]+\\)/\\(pulls\\|issues\\)/\\([0-9]+\\)$" url)
                                         (format "%s/%s/%s" (match-string 1 url)
                                                            (if (string= (match-string 2 url) "pulls") "pull" "issues")
                                                            (match-string 3 url)))))
                                   notifs))))
          (dolist (m msglst)
            (let* ((id (plist-get m :message-id)))
              (when (string-match "^\\([^/]+/[^/]+\\)/\\(pull\\|issues\\)/\\([0-9]+\\)\\(/[^@]+\\)?@github\\.com$" id)
                (let ((notif (format "%s/%s/%s" (match-string 1 id)
                                                (match-string 2 id)
                                                (match-string 3 id))))
                  (when (member notif done)
                    (mu4e-trash-message nil m nil))))))) ;; FIXME: don't trash starred messages
        (apply orig-fun msglst args))
      (advice-remove 'mu4e~headers-append-handler #'mu4e-headers-append-github-notifications)))
  (custom-set-faces
   '(mu4e-replied-face ((t nil)))
   '(mu4e-trashed-face ((t nil)))
   '(mu4e-draft-face ((t nil)))
   '(mu4e-unread-face ((t (:weight bold))))
   '(mu4e-header-highlight-face ((t (:inherit hl-line :underline t))))
   '(mu4e-flagged-face ((t nil)))
   '(mu4e-replied-face ((t nil)))
   '(mu4e-forwarded-face ((t nil)))
   '(mu4e-header-face ((t nil)))
   '(mu4e-thread-fold-face ((t (:background "#e0f4ff"))))
   '(gnus-header ((t nil))) ;; disable variable-pitch-text
                            ;; => FIXME: does this not work anymore with leuven theme?
                            ;;    -> gnus-header is set correctly and other faces normally inherit from it
                            ;;    -> but theme makes them inherit from message-header-other, message-header-to,
                            ;;       message-header-name, message-header-subject, etc.
   )
  ;; auto-completion for search query
  ;; FIXME: don't use advice for interactive functions
  ;; -> do it like mu4e-search-narrow-with-auto-compelte
  (defadvice mu4e-search (before mu4e-search-setup-auto-complete
                                 (&optional expr prompt edit ignore-history msgid show)
                                 activate)
    (unless expr
      (add-hook 'minibuffer-setup-hook 'mu4e-search-minibuffer-setup)
      (add-hook 'minibuffer-exit-hook 'mu4e-search-minibuffer-exit)))
  (defun mu4e-search-narrow-with-auto-complete ()
    (interactive)
    (add-hook 'minibuffer-setup-hook 'mu4e-search-minibuffer-setup)
    (add-hook 'minibuffer-exit-hook 'mu4e-search-minibuffer-exit)
    (mu4e-search-narrow (mu4e-search-read-query (mu4e-format "Narrow down to: "))))
  (defun mu4e-search-minibuffer-setup ()
    (setq-local ac-sources '(ac-source-mu4e-search-from-to
                             ac-source-mu4e-search-tag
                             ac-source-mu4e-search-flag))
    (setq-local ac-menu-height 3)
    (setq-local ac-quick-help-height 3)
    (auto-complete-mode t))
  (defun mu4e-search-minibuffer-exit ()
    (remove-hook 'minibuffer-setup-hook 'mu4e-search-minibuffer-setup)
    (remove-hook 'minibuffer-exit-hook 'mu4e-search-minibuffer-exit))
  (use-package auto-complete
    :config
    (ac-define-source mu4e-search-from-to
      '((prefix     . "\\(?:from:\\|to:\\)\\(\\(\\w\\|[\\.@_-]\\)+\\)")
        (candidates . (lambda ()
                        (let (keys)
                          ;; FIXME: the mu4e--contacts-set variable is not set if mu4e-update isn't running?
                          (maphash (lambda (k v) (push k keys)) mu4e--contacts-set)
                          keys)))
        (match      . (lambda (prefix candicates)
                        (mapcar (lambda (contact)
                                  (if (string-match "<\\(.+\\)>" contact)
                                      (match-string 1 contact)
                                    contact))
                                (ac-match-substring prefix candicates))))
        (document   . (lambda (address)
                        (let ((address-regexp (concat "<" (regexp-quote address) ">"))
                              (contacts (let (keys)
                                          (maphash (lambda (k v) (push k keys)) mu4e--contacts-set)
                                          keys))
                              contact)
                          (while (and contacts (not contact))
                            (setq contact (car contacts))
                            (setq contacts (cdr contacts))
                            (when (not (string-match address-regexp contact))
                              (setq contact nil)))
                          (setq contact (or contact address)))))
        (cache)))
    (ac-define-source mu4e-search-tag
      '((prefix     . "\\(?:tag:\\)\\(\\(\\w\\|/\\)+\\)")
        (candidates . (lambda () (let ((labels (list "\\\\Inbox" "\\\\Sent" "\\\\Trash" "\\\\Important" "\\\\Starred")))
                                   (cl-loop for (superlabel sublabels) on gmail-labels by #'cddr do
                                     (cl-loop for sublabel in sublabels by #'cddr do
                                       (add-to-list 'labels (string-replace " " "\\ "
                                                                            (if sublabel
                                                                                (concat superlabel "/" sublabel)
                                                                              superlabel)) t)))
                                   labels)))
        (match      . substring)
        (cache)))
    (ac-define-source mu4e-search-flag
      '((prefix     . "\\(?:flag:\\)\\(\\(\\w\\|/\\)+\\)")
        (candidates . '("attach" "draft" "flagged" "list" "new" "passed" "replied"
                        "seen" "trashed" "unread" "encrypted" "signed" "personal"))
        (match      . substring)
        (cache))))
  (defface gmail-label-starred-face
    '((t :inherit default :foreground "#A370E0" :family "monospace" :height 0.85)) nil)
  (defface gmail-label-unstarred-face
    '((t :inherit default :foreground "#DDDDDD" :family "monospace" :height 0.85)) nil)
  (defun mu4e-display-tags (tags)
    (string-join
      (append
        `(,(if (member "\\Starred" tags)
               (propertize "★" 'face 'gmail-label-starred-face)
             (propertize "☆" 'face 'gmail-label-unstarred-face)))
        (delq nil
          (mapcar
            (lambda (tag)
              (let ((short-tag
                     (cond ((string-match "^\\\\\\(Inbox\\|Sent\\|Trash\\)$" tag)
                            (match-string 1 tag))
                           ((string-match "^\\(Mailboxen/[^@]+\\)\\(@.+\\)$" tag)
                            (match-string 2 tag))
                           ((string-match "^\\(Tags\\|Mailinglijsten\\|Archieven\\)/\\(.+\\)$" tag)
                            (match-string 2 tag))
                           ((string-match "^Github notifications$" tag)
                            "github")
                           ((string-match "^Github notifications/trash$" tag)
                            "Trash"))))
                (when short-tag
                  (let* ((face (intern (format "gmail-label-%s-face" (string-replace " " "-" tag))))
                         (face (if (facep face) face 'gmail-label-default-face)))
                    (propertize short-tag 'face face)))))
            tags)))
      " "))
  ;; FIXME: patch mu4e instead of overriding whole function
  ;; -> use straight.el for this
  (defvar mu4e-headers-display-tags (lambda (tags) (propertize (mapconcat 'identity tags ", "))))
  (defun mu4e~headers-field-value (msg field)
    (let ((val (mu4e-message-field msg field)))
      (cl-case field
        (:subject
         (concat ;; prefix subject with a thread indicator
          (mu4e~headers-thread-prefix (mu4e-message-field msg :meta))
          ;;  "["(plist-get (mu4e-message-field msg :meta) :path) "] "
          ;; work-around: emacs' display gets really slow when lines are too long;
          ;; so limit subject length to 600
          (truncate-string-to-width val 600)))
        (:thread-subject ;; if not searching threads, fall back to :subject
         (if mu4e-search-threads
             (mu4e~headers-thread-subject msg)
           (mu4e~headers-field-value msg :subject)))
        ((:maildir :path :message-id) val)
        ((:to :from :cc :bcc) (mu4e~headers-contact-str val))
        ;; if we (ie. `user-mail-address' is the 'From', show
        ;; 'To', otherwise show From
        (:from-or-to (mu4e~headers-from-or-to msg))
        (:date (format-time-string mu4e-headers-date-format val))
        (:list (or val ""))
        (:mailing-list (mu4e~headers-mailing-list (mu4e-msg-field msg :list)))
        (:human-date (propertize (mu4e~headers-human-date msg)
                                 'help-echo (format-time-string
                                             mu4e-headers-long-date-format
                                             (mu4e-msg-field msg :date))))
        (:flags (propertize (mu4e~headers-flags-str val)
                            'help-echo (format "%S" val)))
        (:tags (funcall mu4e-headers-display-tags val))
        (:size (mu4e-display-size val))
        (t (mu4e~headers-custom-field-value msg field)))))
  (setq mu4e-headers-display-tags 'mu4e-display-tags)
  (defvar mu4e-mark-retag-arg nil)
  (defadvice mu4e-mark-execute-all (before mu4e-mark-prompt-retag-arg activate)
    (let (marked-for-tag)
      (maphash (lambda (docid val)
                 (let ((mark (car val)))
                   (when (eql mark 'tag)
                     (setq marked-for-tag t))))
               mu4e--mark-map)
      (when marked-for-tag
        (add-hook 'minibuffer-setup-hook 'mu4e-tag-minibuffer-setup)
        (add-hook 'minibuffer-exit-hook 'mu4e-tag-minibuffer-exit)
        (setq mu4e-mark-retag-arg (read-string "Tags for marked messages: ")))))
  (defun mu4e-tag-minibuffer-setup ()
    (setq-local ac-sources '(ac-source-mu4e-tag))
    (setq-local ac-menu-height 3)
    (setq-local ac-quick-help-height 3)
    (auto-complete-mode t)
    (insert "+"))
  (defun mu4e-tag-minibuffer-exit ()
    (remove-hook 'minibuffer-setup-hook 'mu4e-tag-minibuffer-setup)
    (remove-hook 'minibuffer-exit-hook 'mu4e-tag-minibuffer-exit))
  (defun mu4e-mark-execute-all-no-confirmation ()
    (interactive)
    (mu4e-mark-execute-all t))
  (use-package auto-complete
    :config
    (ac-define-source mu4e-tag
      '((prefix     . "\\(?:[\\+\\-]\\)\\(\\(\\w\\|[\\\\/]\\)+\\)")
        (candidates . (lambda () (let ((labels (list "\\Inbox" "\\Trash" "\\Important")))
                                   (cl-loop for (superlabel sublabels) on gmail-labels by #'cddr do
                                     (cl-loop for sublabel in sublabels by #'cddr do
                                       (add-to-list 'labels (string-replace " " "\\ "
                                                                            (if sublabel
                                                                                (concat superlabel "/" sublabel)
                                                                              superlabel)) t)))
                                   labels)))
        (match      . substring)
        (cache))))
  (defun mu4e-tag-message (docid msg target)
    (mu4e-action-retag-message msg mu4e-mark-retag-arg))
  (defun mu4e-trash-message (docid msg target)
    (let ((maildir (mu4e-message-field msg :maildir)))
      (if (string= maildir "/all")
          (if (member "Github notifications" (mu4e-message-field msg :tags))
              (if (not (member 'seen (mu4e-message-field msg :flags)))
                  (mu4e-action-retag-message msg "-Github notifications,+Github notifications/trash")
                (mu4e-action-retag-message msg "+\\Trash"))
            (if (member "Github notifications/trash" (mu4e-message-field msg :tags))
                (mu4e-action-retag-message msg "-Github notifications/trash,+Github notifications,+\\Trash")
              (mu4e-action-retag-message msg "+\\Trash")))
        (when (string= maildir "/trash")
          (mu4e--server-remove docid)))))
  (defun mu4e-star-message (docid msg target)
    (mu4e-action-retag-message msg "+\\Starred"))
  (defun mu4e-unstar-message (docid msg target)
    ;(mu4e-action-retag-message msg "-\\Starred") ;; FIXME: this completely messes up things
    )
  (defun mu4e-archive-message (docid msg target)
    (mu4e-action-retag-message msg "-\\Inbox,-\\Trash,-Github notifications/trash"))
  (defun mu4e-move-message-to-inbox (docid msg target)
    (mu4e-action-retag-message msg "+\\Inbox,-\\Trash,-Github notifications/trash")) ;; FIXME: will Github move the message to maildir:/all?
  (defun mu4e-delete-message-permanently (docid msg target)
    (let ((maildir (mu4e-message-field msg :maildir)))
      (when (string= maildir "/trash")
        (mu4e--server-remove docid))))
  (setq mu4e-marks
    (append mu4e-marks
            '((tag
               :char "t"
               :prompt "tag"
               :show-target (lambda (target) "tag")
               :action mu4e-tag-message)
              (tag-as-trash
               :char "d"
               :prompt "dtrash"
               :show-target (lambda (target) "trash")
               :action mu4e-trash-message)
              (star
               :char "*"
               :prompt "*star"
               :show-target (lambda (target) "star")
               :action mu4e-star-message)
              (unstar
               :char "o"
               :prompt "ounstar"
               :show-target (lambda (target) "unstar")
               :action mu4e-unstar-message)
              (archive
               :char "a"
               :prompt "archive"
               :show-target (lambda (target) "archive")
               :action mu4e-archive-message)
              (inbox
               :char "i"
               :prompt "iMove to inbox"
               :show-target (lambda (target) "inbox")
               :action mu4e-move-message-to-inbox)
              (delete-permanently
               :char "D"
               :prompt "Ddelete"
               :show-target (lambda (target) "delete")
               :action mu4e-delete-message-permanently))))
  (mu4e~headers-defun-mark-for tag)
  (mu4e~headers-defun-mark-for tag-as-trash)
  (mu4e~headers-defun-mark-for star)
  (mu4e~headers-defun-mark-for unstar)
  (mu4e~headers-defun-mark-for archive)
  (mu4e~headers-defun-mark-for inbox)
  (mu4e~headers-defun-mark-for delete-permanently)
  (mu4e--view-defun-mark-for tag)
  (mu4e--view-defun-mark-for tag-as-trash)
  (mu4e--view-defun-mark-for delete-permanently)
  (mu4e--view-defun-mark-for archive)
  (defun mu4e-view-show-in-thread ()
    (interactive)
    (let ((mu4e-search-include-related t))
      (mu4e-search (format "msgid:%s" (mu4e-message-field-at-point :message-id)))))
  (defun mu4e-open-github-issue-link-with-forge (orig-fun &rest args)
    (if (not current-prefix-arg)
        (apply orig-fun args)
      (when-let ((url (or (car args) (mu4e--view-get-property-from-event 'mu4e-url))))
        (or (browse-github-issue-url-with-forge url)
            (apply orig-fun args)))))
  (advice-add 'mu4e--view-browse-url-from-binding :around #'mu4e-open-github-issue-link-with-forge))

(use-package mm-decode
  :config
  (add-to-list 'mm-discouraged-alternatives "text/html")
  (add-to-list 'mm-discouraged-alternatives "text/richtext"))

(use-package mu4e-compose
  :config
  (setq mu4e-compose-complete-addresses t
        mu4e-compose-complete-only-personal nil
        mu4e-compose-complete-only-after "2012-02-01"
        mu4e-compose-complete-ignore-address-regexp "not?-?reply"))

#+END_SRC

** IRC and Slack

see also [[file:~/bin/bitlbee.org::*Bitlbee][Bitlbee]]

- [ ] how come messages on slack are echoed? 

#+NAME: config
#+BEGIN_SRC emacs-lisp
;; see https://github.com/julienXX/erc-terminal-notifier.el
;; FIXME: may need to modify this a bit to get less (or more) notifications
;;        also to get sound
;;        and in order to install terminal-notifier lazily
;; FIXME: see also https://github.com/sinic/ednc (Emacs desktop notification center)
(use-package erc-terminal-notifier
  :ensure t
  :init
  ;; run `make -C ~ terminal-notifier' (brew install terminal-notifier)
  )

(use-package erc
  :commands (libera-chat bitlbee erc-all)
  :config
  (require 'erc-services)
  (require 'erc-terminal-notifier)
  (setq erc-server "localhost"
        erc-server-history-list '("localhost"
                                  "irc.libera.chat")
        erc-nick '("bert" "bfrees")
        erc-nickserv-identify-mode 'both
        ;; NickServ passwords come from .authinfo.gpg
        ;erc-nickserv-passwords
        ;  '((BitlBee     (("bert" .   (password-store-get "bitlbee")))) ;; this didn't seem to work, but passing
                                                                         ;; the password directly to the erc should
        ;    (Libera.Chat (("bfrees" . (password-store-get "libera.chat")))))
        erc-autojoin-channels-alist
          '(("Libera.Chat" "#liblouis")
            ;"BitlBee" ... ;; autojoins for BitlBee are handled by BitlBee itself
            ))
  (defun libera-chat ()
    (interactive)
    (erc-tls :server "irc.libera.chat" :port 6697 :nick "bfrees"))
  (defun bitlbee ()
    (interactive)
    (when (not (get-buffer-process "*bitlbee*"))
      ;; FIXME: pass pid path option  (do this within ../bin/bitlbee)
      ;; FIXME: there is also the -x switch (command-line interface to password encryption/hashing)
      ;; -> is encryption of passwords in config file not safe enough?
      ;; FIXME: better to manage server outside of Emacs
      ;; -> so that restarting Emacs is no issue at all
      ;; -> Makefile: "make bitlbee-start"
      ;; -> using existing daemon?
      ;;    - use -u option to run daemon as specified user (bert)
      ;; -> using launchctl?
      (start-process "bitlbee" "*bitlbee*"
                     (expand-file-name "../bin/bitlbee" user-emacs-directory) "-Fn"))
    (erc :server "localhost" :port 6667 :nick "bert"))
  (defun erc-all ()
    (interactive)
    (libera-chat)
    (bitlbee)))

#+END_SRC

** RSS/Atom

See https://github.com/skeeto/elfeed.

- [ ] look at org-elfeed
  - https://lucidmanager.org/productivity/read-rss-feeds-with-emacs-and-elfeed/

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :ensure t
  :bind ((("C-c w e" . elfeed))
         :map elfeed-search-mode-map
         ("g" . elfeed-search-fetch))
  :config
  (setq elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory)
        elfeed-show-entry-switch 'display-buffer
        elfeed-feeds '("https://feeds.meteoalarm.org/feeds/meteoalarm-legacy-atom-belgium")
        ;; FIXME: make this into a bookmark?
        elfeed-search-filter "@2-days-ago +unread MeteoAlarm Antwerp\\|Brabant Yellow\\|Orange\\|Red #10")
  (elfeed-update)
  (run-at-time nil (* 4 60 60) #'elfeed-update)
  ;; FIXME: test that this works
  (defun elfeed-desktop-notifications (entry)
    "Parse and display new feeds as desktop notifications."
    (start-process "terminal-notifier" "*terminal-notifier*" "terminal-notifier"
                   "-title" (concat
                              (elfeed-feed-title (elfeed-deref (elfeed-entry-feed entry))) "\n"
                              (elfeed-deref (elfeed-entry-title entry)))
                   "-message" (elfeed-deref (elfeed-entry-content entry))
                   "-sound" "default"
                   "-sender" "com.apple.mail"))
  (add-hook 'elfeed-new-entry-hook #'elfeed-desktop-notifications))

#+END_SRC

** Etherpad

- [-] connect through [[https://github.com/ether/etherpad-cli-client][etherpad-cli]] and vterm?
  - [X] sudo npm install -g etherpad-cli-client

#+NAME: config
#+BEGIN_SRC emacs-lisp

#+END_SRC

** White space, indentation

- [ ] use guess-style: https://www.emacswiki.org/emacs/GuessStyle

#+NAME: config
#+BEGIN_SRC emacs-lisp
(require 'whitespace)
;;(global-whitespace-mode)
;; FIXME: this does not seem to work in org-mode source blocks
(setq whitespace-global-modes '(c-mode java-mode nxml-mode clojure-mode emacs-lisp-mode sh-mode makefile-mode))
;; as a workaround, enable whitespace-mode in all programming modes
(add-hook 'prog-mode-hook (lambda () (whitespace-mode t)))

(custom-set-variables
 '(whitespace-style '(face
                      tabs
                      spaces
                      newline
                      space-mark
                      tab-mark
                      newline-mark
                      indentation
                      trailing
                      space-after-tab::tab
                      space-before-tab))
 '(whitespace-trailing-regexp
    "[^\n\t ]\\(\\(\t\\| \\|\xA0\\|\x8A0\\|\x920\\|\xE20\\|\xF20\\)+\\)$")
 '(whitespace-indentation-regexp
    '("^\t*\\(\\( \\)+\\)" . "^ *\\(\t+\\)"))
 '(whitespace-space-after-tab-regexp
    '("\t+\\(\\( \\)+\\)[^ \t]" . "\\(\t+\\) +")))

(custom-set-faces
  '(whitespace-tab              ((t (:foreground "#eeeeee"))))
  '(whitespace-space            ((t (:foreground "#eeeeee"))))
  '(whitespace-newline          ((t (:foreground "#eeeeee"))))
  '(whitespace-hspace           ((t (:foreground "#cccccc"))))
  '(whitespace-indentation      ((t (:foreground "#ffffff" :background "#dddddd"))))
  '(whitespace-trailing         ((t (:foreground "#cccccc" :background "#ffffff"))))
  '(whitespace-space-after-tab  ((t (:foreground "#ffffff" :background "#dddddd"))))
  '(whitespace-space-before-tab ((t (:foreground "#cccccc" :background "#ffffff")))))

(setq-default indent-tabs-mode t)
(setq-default tab-width 4)

;; intelligently indent with tabs, align with spaces
;; see https://www.emacswiki.org/emacs/SmartTabs
(use-package smart-tabs-mode :ensure t)
(require 'cl-lib)
;; to avoid "eager macro-expansion skipped due to cycle" error
(cl-letf (((symbol-function 'internal-macroexpand-for-load) nil))
  (fmakunbound 'internal-macroexpand-for-load)
  (require 'smart-tabs-mode))

#+END_SRC

** Programming

- [ ] set up yasnippet
  - ~(use-package yasnippet :config (yas-global-mode))~

#+NAME: config
#+BEGIN_SRC emacs-lisp
(smart-tabs-add-language-support c c-mode-hook
  ((c-indent-line . c-basic-offset)
   (c-indent-region . c-basic-offset)))
(smart-tabs-add-language-support java java-mode-hook
  ((c-indent-line . c-basic-offset)
   (c-indent-region . c-basic-offset)))
(smart-tabs-add-language-support xml nxml-mode-hook
  ((nxml-indent-line . nxml-child-indent)))
(smart-tabs-add-language-support html html-mode-hook
  ((sgml-indent-line . sgml-basic-offset)))

(smart-tabs-insinuate 'c 'java 'xml 'html)

#+END_SRC

#+NAME: config
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
(global-flycheck-mode)

#+END_SRC

#+NAME:config
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :ensure t
  :commands lsp
  :hook (lsp-mode . company-mode)
  :init
  (setq lsp-keymap-prefix "C-l")
  :bind (:map lsp-mode-map
              ("<tab>" . company-indent-or-complete-common))
  :config
  (use-package lsp-treemacs
    :ensure t
    ;; FIXME: the first time a file is opened, the symbols buffer is opened, but not the file itself
    ;; FIXME: cursors stays in symbols buffer: should be moved back to file
    ;; :hook ((lsp-mode . lsp-treemacs-symbols))
    :config
    (setq lsp-treemacs-sync-mode t))
  
  (use-package lsp-ui
    :ensure t
    :config
    (setq lsp-ui-sideline-show-diagnostics t
          lsp-ui-sideline-show-code-actions nil)))

#+END_SRC

*** XML, HTML

#+NAME: config
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.xml$"   . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.xhtml$" . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.xsd$"   . nxml-mode))

(use-package nxml-mode
  :autoload nxml-mode
  :config
  (setq-default nxml-child-indent 4)
  (setq nxml-slash-auto-complete-flag t)
  (push (expand-file-name "schema/schemas.xml" user-emacs-directory) rng-schema-locating-files)
  (add-to-list 'hs-special-modes-alist
    '(nxml-mode "<!--\\|<[^/>]>\\|<[^/][^>]*[^/]>"
                ""
                "<!--"
                nxml-forward-sexp
                nil))
  (add-hook 'nxml-mode-hook
    (lambda () (local-set-key (kbd "TAB") 'nxml-indent-or-toggle-hiding-or-expand-or-complete)
               (local-set-key (kbd "RET") 'nxml-newline-and-indent-maybe-auto-newline)
               (local-set-key ">" 'nxml-electric-gt)
               (local-set-key (kbd "C-<up>") 'nxml-backward-element)
               (local-set-key (kbd "C-<down>") 'nxml-forward-element)
               (setq-local ac-sources '(ac-source-nxml-tag
                                        ac-source-nxml-attr
                                        ac-source-nxml-attr-value))
               (auto-complete-mode t)
               (auto-complete-nxml-init-project)
               (hs-minor-mode)))
  (defun nxml-forward-sexp (arg)
    (let ((nxml-sexp-element-flag))
      (setq nxml-sexp-element-flag (not (looking-at "<!--")))
      (unless (looking-at "[*]+")
        (condition-case nil
            (nxml-forward-balanced-item arg)
          (error nil)))))
  ;; FIXME: what is the relationship with: tab-always-indent? (https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode_002dSpecific-Indent.html)
  (defun try-indent ()
    (if (use-region-p)
        (progn
          (indent-region (region-beginning) (region-end))
          t)
      (let* ((point-before-indent (point)))
        (indent-according-to-mode)
        (not (and (equal point-before-indent (point))
                  (not mark-active))))))
  (defun fallback-command (&optional except-command)
    (let* ((saved-local-map (current-local-map)))
      (use-local-map nil)
      (setq unread-command-events
            (append (this-single-command-raw-keys)
                    unread-command-events))
      (let* ((key (read-key-sequence-vector ""))
             (command (and key (key-binding key))))
        (when (and (commandp command)
                   (not (eq command 'except-command)))
          (setq this-command command)
          (call-interactively command))
        (use-local-map saved-local-map))))
  (defun nxml-try-toggle-hiding ()
    (if (hs-already-hidden-p)
      (progn
        (hs-show-block)
        (hs-find-block-beginning)
        t)
      (progn
        (nxml-token-after)
        (when (or (and (eq xmltok-type 'start-tag)
                       (< (- (point) xmltok-start 1) (length (xmltok-start-tag-qname))))
                  (and (eq xmltok-type 'comment)
                       (< (- (point) xmltok-start) 4)))
          (goto-char xmltok-start)
          (hs-hide-block)
          (hs-find-block-beginning)
          t))))
  (defun nxml-indent-or-toggle-hiding-or-expand-or-complete ()
    (interactive)
    (unless (try-indent)
      (unless (nxml-try-toggle-hiding)
        (fallback-command 'nxml-indent-or-toggle-hiding-or-expand-or-complete))))
  (defun nxml-newline-and-indent-maybe-auto-newline ()
    (interactive)
    (nxml-ensure-scan-up-to-date)
    (if (and (not (nxml-get-inside (point)))
             (eq (point) (nxml-scan-element-backward (point) t))
             (looking-at (concat "</" (xmltok-start-tag-qname) ">")))
        (progn
          (newline)
          (save-excursion (newline))
          (nxml-indent-line)
          (save-excursion (forward-char)
                          (nxml-indent-line)))
      (newline)
      (nxml-indent-line)))
  (defun nxml-electric-gt ()
    (interactive)
    (nxml-ensure-scan-up-to-date)
    (insert ">")
    (if (and (eq (nxml-token-before) (point))
             (eq xmltok-type 'start-tag))
        (save-excursion
          (insert (concat "</" (xmltok-start-tag-qname) ">")))))
  (defun nxml-electric-slash (arg)
    (interactive "*P")
    (nxml-ensure-scan-up-to-date)
    (let* ((slash-pos (point))
           (end-tag-p (and (eq (char-before slash-pos) ?<)
                           (not (nxml-get-inside slash-pos))))
           (at-indentation (save-excursion
                             (back-to-indentation)
                             (eq (point) (1- slash-pos)))))
      (self-insert-command (prefix-numeric-value arg))
      (unless arg
        (if nxml-slash-auto-complete-flag
            (if end-tag-p
                (condition-case err
                    (let ((start-tag-end
                           (nxml-scan-element-backward (1- slash-pos) t)))
                      (when start-tag-end
                        (insert (xmltok-start-tag-qname) ">")))
                  (nxml-scan-error nil))
              (if (and (eq (nxml-token-before) (point))
                       (eq xmltok-type 'partial-empty-element))
                  (insert ">")
                (when (and (eq (nxml-token-before) (1+ (point)))
                           (eq xmltok-type 'empty-element))
                  (forward-char)
                  (when (looking-at (concat "[\s\t\n]*</" (xmltok-start-tag-qname) ">"))
                    (while (looking-at "[\s\t\n]")
                      (delete-char 1))
                    (delete-char (+ 3 (length (xmltok-start-tag-qname)))))))))
        (when (and end-tag-p at-indentation)
          (nxml-indent-line)))))
  (defun nxml-pretty-print-region (begin end)
    (interactive "r")
    (when (string-equal major-mode "nxml-mode")
      (save-excursion
        (goto-char begin)
        (while (search-forward-regexp "\>[ \\t]*\<" nil t)
          (backward-char) (insert "\n"))
        (indent-region begin end))))) 

(use-package auto-complete-nxml
  :ensure t
  :autoload auto-complete-nxml-init-project
  :config
  (remove-hook 'nxml-mode-hook 'auto-complete-nxml-setup))

(setq-default sgml-basic-offset 4)

#+END_SRC

*** C, Java

#+NAME:config
#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :config
  (defconst c-my-java-style
    '("java"
      (c-offsets-alist . ((arglist-intro . +)
                          (arglist-close . 0)))))
  (c-add-style "my-java" c-my-java-style)
  (defun c-set-java-style ()
    (interactive)
    (c-set-style "my-java")
    (setq indent-tabs-mode t)
    (setq tab-width 4)
    (setq c-basic-offset 4)
    (if whitespace-mode
      (whitespace-turn-on)))
  (add-hook 'c-mode-common-hook #'c-set-java-style))

#+END_SRC

#+NAME:config
#+BEGIN_SRC emacs-lisp
(use-package lsp-java
  :ensure t
  :demand t
  ;; :hook ((java-mode . lsp))
  :config
  (setq lsp-java-autobuild-enabled nil))

;;(use-package helm-lsp :commands helm-lsp-workspace-symbol)
;;(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
;;(use-package dap-mode :after lsp-mode :config (dap-auto-configure-mode))
;;(use-package dap-java :ensure nil)
;;(use-package projectile)

#+END_SRC

*** Lisp, Clojure

#+NAME:config
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters :ensure t)

(use-package clojure-mode
  :ensure t
  :mode ("\\.clj\\'" "\\.cljc\\'")
  :interpreter ("clojure" "bb")
  :bind (:map clojure-mode-map
              (("C-x C-e" . clojure-vterm-execute-region-or-current-line)))
  :config
  (defvar clojure-vterm-execute-buffer nil)
  (defun clojure-vterm-execute-region-or-current-line ()
    "Insert text of current line in vterm and execute."
    (interactive)
    (require 'vterm)
    (eval-when-compile (require 'subr-x))
    (let ((command (if (region-active-p)
                       (string-trim (buffer-substring
                                     (save-excursion (region-beginning))
                                     (save-excursion (region-end))))
                     (string-trim (buffer-substring (save-excursion
                                                      (thing-at-point--beginning-of-sexp)
                                                      (point))
                                                    (point))))))
      (let* ((buf (current-buffer))
             (vterm-buffer
              (or (and (buffer-live-p clojure-vterm-execute-buffer) clojure-vterm-execute-buffer)
                  (set (make-local-variable 'clojure-vterm-execute-buffer)
                       (let ((vterm-shell "clojure")) ;; or "bb"
                         (vterm))))))
        (display-buffer vterm-buffer t)
        (switch-to-buffer-other-window vterm-buffer)
        (vterm--goto-line -1)
        (message command)
        (vterm-send-string command)
        (vterm-send-return)
        (switch-to-buffer-other-window buf)))))

;(add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
;(add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)

;; indent-tabs-mode is automatically set to nil for elisp, except in org-mode source block edit buffers
(add-hook 'emacs-lisp-mode-hook (lambda () (setq-local indent-tabs-mode nil)))

#+END_SRC

** Shell

See also [[file:../.zshrc.org][.zshrc]]

- [ ] currently yank/kill/copy works through interprogram-killring, but could I make key bindings
  for vterm-mode to do it via Emacs itself?
  - see vterm-yank-primary?
- [ ] for some reason the initial *vterm* buffer does not adapt its width to the window width
  - nothing to do with vterm vs. multi-vterm
  - nothing to do with initial-buffer-choice function
  - but probably has everything to do with how emacs is started

#+NAME: config
#+BEGIN_SRC emacs-lisp
(defun vterm-buffer-for-directory (&optional directory)
  (let* ((directory (or directory default-directory))
         (directory (expand-file-name directory))
         (buf (if current-prefix-arg
                  nil ;; create new buffer if current-prefix-arg is set
                (progn
                  (require 'cl-lib)
                  (cl-loop for b in (match-buffers '(major-mode . vterm-mode))
                           when (string= directory (expand-file-name
                                                    (buffer-local-value 'default-directory b)))
                           return b))))
         (buf (or buf
                  (let ((default-directory directory))
                    (vterm)))))
    (with-current-buffer buf
      (vterm-dark-theme)) ;; Note that vterm-dark-theme is already applied in vterm-mode-hook,
                          ;; but vterm-mode-hook does not seem te be executed when vterm is
                          ;; started through initial-buffer-choice. Also, for some reason,
                          ;; vterm-dark-theme is not applied correctly to the very first vterm
                          ;; buffer (when the daemon is started), so call it again when
                          ;; emacsclient connects (and every time vterm-buffer-for-directory is
                          ;; called).
    buf))

(defun switch-to-vterm-buffer-for-directory (&optional directory)
  (interactive)
  (switch-to-buffer (vterm-buffer-for-directory directory)))

(setq initial-buffer-choice #'vterm-buffer-for-directory)

;;     C-x !: switch to vterm buffer for current directory
;; C-u C-x !: create new vterm buffer for current directory
;; FIXME: command for switching to vterm buffer for current project (C-u C-u C-x t?)
(global-set-key (kbd "C-x !") 'switch-to-vterm-buffer-for-directory)

(use-package theme-anchor :ensure t)

(use-package vterm
  :ensure t
  :autoload vterm--internal
  :bind (:map vterm-mode-map
         ("C-c C-p" . vterm-copy-mode)
         :map vterm-copy-mode-map
         ("C-c C-p" . vterm-copy-mode-done))
  :config
  (setq vterm-buffer-name-string "vterm %s")
  (defun vterm-dark-theme ()
    "Dark theme for vterm buffers."
    (ignore-errors
      (unless (color-dark-p (mapcar (lambda (c) (/ c 65535.0))
                                    (color-values (background-color-at-point))))
        (require 'theme-anchor)
        (theme-anchor-buffer-local 'modus-vivendi))))
  (add-hook 'vterm-mode-hook #'vterm-dark-theme)
  (defvar vterm-execute-buffer nil)
  (defun vterm-execute-region-or-current-line ()
    "Insert text of current line in vterm and execute."
    (interactive)
    (require 'vterm)
    (eval-when-compile (require 'subr-x))
    (let ((command (if (region-active-p)
                       (string-trim (buffer-substring
                                     (save-excursion (region-beginning))
                                     (save-excursion (region-end))))
                     (string-trim (buffer-substring (save-excursion
                                                      (beginning-of-line)
                                                      (point))
                                                    (save-excursion
                                                      (end-of-line)
                                                      (point)))))))
      (let* ((buf (current-buffer))
             (vterm-buffer
              (or (and (buffer-live-p vterm-execute-buffer) vterm-execute-buffer)
                  (if-let ((vterm-buffers (match-buffers '(major-mode . vterm-mode))))
                      (if (= 1 (length vterm-buffers))
                          (car vterm-buffers)
                        (set (make-local-variable 'vterm-execute-buffer)
                             (get-buffer
                              (completing-read "Send command to shell: "
                                               (mapcar #'buffer-name vterm-buffers)
                                               nil t))))
                    (let ((default-directory (read-directory-name
                                              "Send command to new shell in directory: "
                                              default-directory nil t)))
                      (vterm))))))
        (display-buffer vterm-buffer t)
        (switch-to-buffer-other-window vterm-buffer)
        (vterm--goto-line -1)
        (message command)
        (vterm-send-string command)
        (vterm-send-return)
        (switch-to-buffer-other-window buf))))
  (use-package sh-script
    :bind (:map sh-mode-map
                (("C-x C-e" . vterm-execute-region-or-current-line)))))

#+END_SRC

** Putting it all together

#+NAME: init.el
#+BEGIN_SRC emacs-lisp :tangle init.el
;; This file is automatically generated from init.el.org. Don't make
;; changes to this file directly.

<<config>>
#+END_SRC
